#+TITLE: FrostyX's Emacs configuration
#+AUTHOR: Jakub Kadlčík


This Emacs configuration is a mess. I am a newbie trying to hack things together
and experiment. Do not take anything from this configuration unles you know what
you are doing. Because the odds are, that I am not.

* Table of Contents :TOC:
- [[#things-to-do][Things to do]]
- [[#defaults][Defaults]]
- [[#package-management][Package management]]
- [[#secrets][Secrets]]
- [[#living-in-evil][Living in Evil]]
  - [[#evil-leader][Evil leader]]
  - [[#evil-mode][Evil Mode]]
  - [[#evil-packages][Evil packages]]
  - [[#vim-keybindings-everywhere][Vim keybindings everywhere]]
  - [[#more-vim-compatibility][More Vim compatibility]]
  - [[#custom-evil-keybindings][Custom Evil keybindings]]
  - [[#custom-evil-commands][Custom Evil commands]]
- [[#interface][Interface]]
  - [[#gui][GUI]]
  - [[#themes][Themes]]
  - [[#fonts][Fonts]]
  - [[#ux][UX]]
- [[#project-management][Project management]]
- [[#sessions][Sessions]]
- [[#development][Development]]
  - [[#completion][Completion]]
  - [[#whitespace][Whitespace]]
  - [[#languages][Languages]]
  - [[#lsp][LSP]]
- [[#writing][Writing]]
- [[#applications][Applications]]
  - [[#file-manager][File manager]]
  - [[#web][Web]]
  - [[#email][Email]]
  - [[#rss][RSS]]
  - [[#spotify][Spotify]]
  - [[#networkmanager][NetworkManager]]
  - [[#bluetooth][Bluetooth]]
  - [[#pulseaudio][Pulseaudio]]
- [[#resources][Resources]]
  - [[#other-people-configs][Other people configs]]
  - [[#videos][Videos]]

* Oh-shit buttons

In case you do something and have no idea how to save yourself.

Reset variable to its default value, press ~M-:~ and run:

#+BEGIN_SRC
(custom-reevaluate-setting 'emms-player-next-function)
#+END_SRC

Sometimes, when the whole Emacs freezes and ~C-g~ doesn't help, poke it from the
terminal with

#+BEGIN_SRC bash
kill -SIGUSR2 <pid>
#+END_SRC

It should get Emacs unstuck. For easier debugging it might be enough to
~M-x toggle-debug-on-quit~ and then hit ~C-g~ to pop up a ~*Backtrace*~ buffer.

Also, it may be useful to see all processes running within Emacs. Try ~M-x
list-processes~. To kill a process, run

#+BEGIN_EXAMPLE emacs-lisp
(kill-process "process-name")
#+END_EXAMPLE

* Facts

Similar to ~ansible_facts~, we are going to inspect the system that we are
currently running, so we can adjust our Emacs configuration
appropriately. Namely we want to differentiate between operating systems
(GNU/Linux, Windows, Android) and also purpose of the OS. We want the most
complete Emacs configuration only on a proper workspace. Everywhere else just a
compact setup that doesn't require any system dependencies.

The ~android-p~ predicate is based on an environment variable that is defined
defined at least in Termux. The ~workstation-p~ predicate is based on system
hostname.

#+BEGIN_SRC emacs-lisp
(setq gui-p         (display-graphic-p)
      cli-p         (not gui-p)
      android-p     (getenv "ANDROID_ROOT")
      linux-p       (and (eq system-type 'gnu/linux) (not android-p))
      windows-p     (eq system-type 'windows-nt)
      workstation-p (member (system-name)
                            '("chromie" "alarak" "zeratul")))
#+END_SRC

* Defaults

For whatever reason, Emacs modifies hand-written ~init.el~ and puts random
customizations in there. Git tracks them and throws them at us. I do not care
about them! Emacs, please write customizations to a separate file that I can put
into ~.gitignore~.

#+BEGIN_SRC emacs-lisp
(setq custom-file (concat user-emacs-directory "custom.el"))
(if (file-exists-p custom-file)
    (load custom-file))
#+END_SRC


#+BEGIN_SRC emacs-lisp
;; https://www.emacswiki.org/emacs/AutoPairs
;; TODO try https://github.com/Fuco1/smartparens instead
(electric-pair-mode)


;; Middle-click paste where cursor is, don't care about mouse position
;; https://superuser.com/questions/330849/can-i-tell-emacs-to-paste-middle-mouse-button-on-the-cursor-position
(setq mouse-yank-at-point t)


;; Automatically reload changed files
;; https://stackoverflow.com/q/1480572/3285282
(global-auto-revert-mode t)


;; keyboard scroll one line at a time
;; scroll when cursor is five lines from the edge
;; and don't ever recenter the cursor when scrolling
(setq scroll-step 1)
(setq scroll-margin 5)
(setq scroll-conservatively 101)


;; Don't throw "Invalid coding system" errors on me when writting a file
(define-coding-system-alias 'UTF-8 'utf-8)


;; Don't mess CWD with #foo.py# and foo.py~ files
;; https://emacs.stackexchange.com/a/34
;; (setq backup-directory-alist '(("." . "~/MyEmacsBackups")))
;; (setq backup-directory-alist '("~/MyEmacsBackups"))
;; (setq backup-directory-alist `(("." . "~/MyEmacsBackups")))


;; https://stackoverflow.com/a/18330742/3285282
(setq backup-by-copying t               ; don't clobber symlinks
      version-control t                 ; version numbers for backup files
      delete-old-versions t             ; delete excess backup files silently
      delete-by-moving-to-trash t
      kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
      kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
      auto-save-default t               ; auto-save every buffer that visits a file
      )
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook #'display-line-numbers-mode)
(save-place-mode 1)
#+END_SRC

Let's have some funny message on the top of the ~*scratch*~ buffer.

#+BEGIN_SRC emacs-lisp
(setq initial-scratch-message ";; Do you even lisp, bro? ಠ_ಠ\n\n\n")
#+END_SRC


We don't want to quit emacs. Ever! Sometimes it happens to me, that I
accidentally type ~:wq~ because I want to close the current buffer but don't
realize that I am not in any split, so this is my last visible buffer. In such
case, Emacs gets killed and it sucks so bad (because I have ten eyebrowse
workspaces full of things, they are just not currently visible). So, let's take
this safety measure and ask everytime before quiting.

#+BEGIN_SRC emacs-lisp
(setq confirm-kill-emacs 'y-or-n-p)
#+END_SRC

** Keep folders clean

Watch this great explanation about Emacs temporary files such as backups,
autosaves, etc: https://www.youtube.com/watch?v=XZjyJG-sFZI

The show notes can be found here
https://github.com/daviwil/emacs-from-scratch/blob/master/show-notes/Emacs-Tips-Cleaning.org

Don't clutter project directories with backup files,
e.g. ~Emacs.org\~~.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist
      `(("." . ,(expand-file-name "tmp/backups/" user-emacs-directory))))
#+END_SRC

Don't clutter project directories with autosave files,
e.g. ~#Emacs.org#~.

#+BEGIN_SRC emacs-lisp
;; auto-save-mode doesn't create the path automatically!
(make-directory (expand-file-name "tmp/auto-saves/" user-emacs-directory) t)

(setq auto-save-list-file-prefix
      (expand-file-name "tmp/auto-saves/sessions/" user-emacs-directory))

(setq auto-save-file-name-transforms
      `((".*" ,(expand-file-name "tmp/auto-saves/" user-emacs-directory) t)))
#+END_SRC

Don't clutter project directories with random garbage generated by Emacs
packages.

#+BEGIN_SRC emacs-lisp
(use-package no-littering
  :ensure t)
#+END_SRC

* Daemon mode

See this great blogpost about running multiple Emacs daemons using systemd
https://tychoish.com/post/running-emacs/

See https://www.youtube.com/watch?v=ZjCRxAMPdNc
See https://github.com/daviwil/emacs-from-scratch/blob/d24357b488862223fecaebdad758b136b0ca96e7/show-notes/Emacs-Tips-08.org

The biggest blocker for me to switch to daemon mode is that Eyebrowse doesn't
support sharing workspaces accross all frames (i.e. closing an emacsclient will
destroy all its workspaces)

* Package management
** Automatical updates

We want to automatically update Emacs packages in order to avoid annoying warnings
during startup, that some package is recommended to be updated.

Update automatically every night, don't ask for confirmation and don't bother us
with update at Emacs startup.

See https://emacs.stackexchange.com/a/31904

#+BEGIN_SRC emacs-lisp
(use-package auto-package-update
   :ensure t
   :config
   (setq auto-package-update-delete-old-versions t
         auto-package-update-interval 365
         auto-package-update-prompt-before-update nil
         auto-package-update-hide-results t)
   (auto-package-update-at-time "04:00"))
#+END_SRC

Unfortunatelly updating takes around two minutes which is long enough to get
disconnected from IRC, which is super annoying. As a temporary workaround let's
update only once a year. We are waiting for async updates.

See https://github.com/rranelli/auto-package-update.el/issues/39

When the update is failing, it starts to ask whether to kill the buffers
or what. Don't do that.

See https://emacs.stackexchange.com/q/14509

#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions nil)
#+END_SRC

Some packages won't properly reload their configuration after update and break.
We need to take care of that.

#+BEGIN_SRC emacs-lisp
(add-hook 'auto-package-update-after-hook
          (lambda ()
            (load-library "yasnippet-snippets.el")))
#+END_SRC

** Quelpa

Quelpa is a package management tool to compile and install Emacs Lisp packages
directly from upstream (i.e from git repository hosted for example on Git Hub),
in opposite to installing them from ELPA or MELPA.

#+BEGIN_SRC emacs-lisp
(use-package quelpa
  :ensure t)
#+END_SRC

By default, Quelpa is called by its own ~quelpa~ function, which is /meh/. Let's
use use integration with ~use-package~.

#+BEGIN_SRC emacs-lisp
(use-package quelpa-use-package
  :ensure t)
#+END_SRC

We often want to use Quelpa for our own patched versions of packages that are
otherwise available and previously installed from MELPA.

#+BEGIN_SRC emacs-lisp
(setq quelpa-upgrade-p t)
#+END_SRC

** System packages

Some third-party Emacs packages are built around or internally use
system packages or executables. We can install them from within the
Emacs configuration.

See https://gitlab.com/jabranham/system-packages

#+BEGIN_SRC emacs-lisp
(use-package system-packages
  :load-path "/home/jkadlcik/git/system-packages"
  :ensure t)
#+END_SRC

I don't want to guess my package manager because running this
configuration on a different system could lead to inconsistencies or
failures because of different package names. Instead, let's define
helper functions for each package manager that we care about and
specify packages for each package manager explicitly.

#+BEGIN_SRC emacs-lisp
(defun frostyx/dnf (&key install)
  (let ((system-packages-package-manager 'dnf)
        (system-packages-use-sudo t))
	(or (frostyx/rpm-query install)
	  (system-packages-install install))))
#+END_SRC

We need to use ~system-packages-install~ instead of
~system-packages-ensure~ to avoid asking for sudo password even though
the packages are already installed.

#+BEGIN_SRC emacs-lisp
(defun frostyx/rpm-query (pack)
  (equal 0 (shell-command
            (concat "rpm -q " pack))))
#+END_SRC

Just in case, set the package manager defaults to something expected

#+BEGIN_SRC emacs-lisp
(setq system-packages-package-manager 'dnf)
(setq system-packages-use-sudo t)
#+END_SRC

* Secrets

Please do not hardcode your passwords or secret information into source code.
Store them into some keyring application (e.g. ~pass~) and query them instead.
This solution provides many advantages:

1. You can safely share your configs publicly without exposing sensitive data,
   /*duh*/
2. No messing with partially commiting files just to leave the sensitive parts
3. In comparison to including a git ignored file with password definitions,
   keyrings have strong encryption

See:
- https://www.passwordstore.org/
- https://medium.com/@chasinglogic/the-definitive-guide-to-password-store-c337a8f023a1

#+BEGIN_SRC emacs-lisp
(use-package password-store
  :ensure t)
#+END_SRC

* Key bindings

As per usual, we have half a dozen ways to do something in Emacs, in this case
customizing key bindings. There is ~global-set-key~ for global key definitions,
~define-key~ for mode-specific definitions (or global definitions as well, when
using ~global-map~), ~evil-define-key~ for Vim users, and many more than I am
not aware of. For unbinding keys, we have ~global-unset-key~ or binding
something to ~nil~. Brace yourselves, we are going to introduce even more
options.

General seems to be the most convinient and consitent way manage key bindings
for both octopuses and Evil users.

See https://github.com/noctuid/general.el

#+BEGIN_SRC emacs-lisp
(use-package general
  :ensure t)
#+END_SRC

Provide Vim-like definers such as ~general-nmap~, ~general-imap~,
~general-vmap~, etc.

See https://github.com/noctuid/general.el#vim-like-definers

#+BEGIN_SRC emacs-lisp
(general-evil-setup)
#+END_SRC

Be consistent and map key bindings like this

#+BEGIN_EXAMPLE emacs-lisp
(general-nmap "KEY" 'command)
#+END_EXAMPLE

Or for a specific mode

#+BEGIN_EXAMPLE emacs-lisp
(general-nmap
  :keymaps 'some-mode-map
  "KEY" 'command)
#+END_EXAMPLE

And unbind key bindings like this (you can ommit the mode map)

#+BEGIN_EXAMPLE emacs-lisp
(general-unbind 'normal some-mode-map "KEY")
#+END_EXAMPLE

* Living in Evil

@TODO link the great blog post explaining emacs key bindings

TODO rant about Emacs key bindings

TODO xkcd image mocking Emacs keybindings

See https://github.com/noctuid/evil-guide


These two needs to be set before we even try to load Evil (or ~evil-collection~ or
~evil-leader~).

See
- https://github.com/emacs-evil/evil-collection#installation
- https://github.com/emacs-evil/evil-collection/issues/215

#+BEGIN_SRC emacs-lisp
(setq evil-want-keybinding nil)
(setq evil-want-integration t)
#+END_SRC

** Evil leader
A common way to define custom key bindings for Vim ~NORMAL~ mode is by utilizing
so called ~<leader>~ key. By default it is mapped to ~\~ but can be remaped to
something else (in my case to comma). Custom mappings are then defined a sequence
of ~<leader>~ key followed by one or more letters. An example can be ~\ga~ for
~git add~ and ~\gc~ for ~git commit~.

For Emacs, this functionality is implemented in ~evil-leader~ package.

See https://github.com/cofi/evil-leader

According to documentation we need to enable ~evil-leader-mode~ before ~evil-mode~.

#+BEGIN_QUOTE
Note: You should enable global-evil-leader-mode before you enable evil-mode,
otherwise evil-leader won’t be enabled in initial buffers (*scratch*, *Messages*, …).
#+END_QUOTE

I don't know about these, but more importantly ~evil-leader~ needs to go first,
otherwise it doesn't work in ~org-mode~.

#+BEGIN_SRC emacs-lisp
(use-package evil-leader
  :ensure t
  :config
  (evil-leader/set-leader ",")
  (global-evil-leader-mode))
#+END_SRC

** Evil Mode

See:
- https://github.com/emacs-evil/evil
- https://www.reddit.com/r/emacs/comments/726p7i/evil_mode_and_use_package/dnh3338?utm_source=share&utm_medium=web2x

#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t ;; install the evil package if not installed
  :init ;; tweak evil's configuration before loading it
  (setq evil-search-module 'evil-search)
  (setq evil-ex-complete-emacs-commands nil)
  (setq evil-vsplit-window-right t)
  (setq evil-split-window-below t)
  (setq evil-shift-round nil)
  (setq evil-want-C-u-scroll t)


  (setq evil-ex-set-initial-state 'normal)

  :config ;; tweak evil after loading it
  (evil-mode))
#+END_SRC

Let's unbind arrow keys for movement. I exclusively use ~hjkl~, so the arrow
keys for movement are useless. On the other hand, they might come handy for
other applications such as IRC client to show previous messages in the prompt or
for terminal application to show previous commands.

#+BEGIN_SRC emacs-lisp
(eval-after-load "evil-maps"
  (dolist (map '(evil-motion-state-map
                 evil-insert-state-map
                 evil-emacs-state-map))
    (define-key (eval map) (kbd "<up>") nil)
    (define-key (eval map) (kbd "<down>") nil)
    (define-key (eval map) (kbd "<left>") nil)
    (define-key (eval map) (kbd "<right>") nil)))
#+END_SRC

@TODO this ^^ requires restarting ~evil-mode~ to have an effect

We seem to need to set how undo/redo should work, otherwise it doesn't work.
https://github.com/syl20bnr/spacemacs/issues/14036#issuecomment-707072523

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :config
  (global-undo-tree-mode)
  (evil-set-undo-system 'undo-tree))
#+END_SRC

** Evil packages

TODO evil-indent-surround

#+BEGIN_SRC emacs-lisp
;; (use-package evil-surround
;;   :ensure t
;;   :config
;;   (global-evil-surround-mode))
#+END_SRC

TODO evil-indent-textobject

#+BEGIN_SRC emacs-lisp
;; ;; @FIXME missing config
;; (use-package evil-indent-textobject
;;   :ensure t)
#+END_SRC


When programming, it is usefull to comment-out pieces of a code to temporarily disable them.
This is valuable when refactoring something and deciding what implementation to use, when
temporarily adding and then enabling/disabling breakpoints, etc. I do it thousand times a day.
Instead of removing the lines and then undoing back, or maybe weirdly commenting the code
line by line, use ~evil-commentary~.

See https://github.com/linktohack/evil-commentary

The usage is straightforward. In ~NORMAL~ mode press ~gcc~ to comment the current line of code.
If it is already commented, it will uncomment it. This behavior is same for all the following
commands. To comment e.g. next 3 lines, use ~3gcc~. To comment a ~VISUAL~ selection, press
~gc~. Another useful option is to do ~gy~ which comments the selection but yanks it first.

#+BEGIN_SRC emacs-lisp
(use-package evil-commentary
  :ensure t
  :config
  (evil-commentary-mode))
#+END_SRC

** Vim keybindings everywhere

#+BEGIN_SRC emacs-lisp
(use-package evil-collection
  :after evil
  :ensure t
  :config
  (evil-collection-init))

;; use evil mode in the buffer created from calling `M-x list-packages'.
;; https://blog.aaronbieber.com/2016/01/23/living-in-evil.html#adding-hjkl-bindings-
(evil-add-hjkl-bindings occur-mode-map 'emacs
  (kbd "/")       'evil-search-forward
  (kbd "n")       'evil-search-next
  (kbd "N")       'evil-search-previous
  (kbd "C-d")     'evil-scroll-down
  (kbd "C-u")     'evil-scroll-up
  (kbd "C-w C-w") 'other-window)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq evil-default-state 'normal) ;; changes default state to emacs
#+END_SRC

TODO ctrl+w hjkl is too slow

#+BEGIN_SRC emacs-lisp
(general-nmap
 "C-h" 'evil-window-left
 "C-j" 'evil-window-down
 "C-k" 'evil-window-up
 "C-l" 'evil-window-right)
#+END_SRC

TODO package manager key bindings, these needs to go somewhere else

See https://www.reddit.com/r/emacs/comments/7dsm0j/how_to_get_evilmode_hjkl_to_work_inside_mx/

#+BEGIN_SRC emacs-lisp
(evil-define-key 'normal package-menu-mode-map (kbd "m") #'package-menu-mark-install)
(evil-define-key 'normal package-menu-mode-map (kbd "u") #'package-menu-mark-unmark)
(evil-define-key 'normal package-menu-mode-map (kbd "x") #'package-menu-execute)
#+END_SRC

** More Vim compatibility

#+BEGIN_SRC emacs-lisp
;; https://emacsredux.com/blog/2014/08/27/a-peek-at-emacs-24-dot-4-superword-mode/
;; #@FIXME using this manually in a python file works, but this config setting not
;; Probably `global-*' mode settings will be required here. Wihout global, the setting
;; is only for the current buffer
;; (superword-mode)
(global-superword-mode)


;; https://emacs.stackexchange.com/a/9584
;; Superword mode seems to apply only on searching, adding also this,
;; to get w, yiw, dw, etc working as expected
(modify-syntax-entry ?_ "w")

;; https://github.com/syl20bnr/spacemacs/blob/develop/doc/FAQ.org#include-underscores-in-word-motions
;; (add-hook 'prog-mode-hook #'(lambda () (modify-syntax-entry ?_ "w")))
;; (add-hook 'mhtml-mode-hook #'(lambda () (modify-syntax-entry ?_ "w")))

;; https://emacs.stackexchange.com/questions/9583/how-to-treat-underscore-as-part-of-the-word/20717#20717
;; (with-eval-after-load 'evil
;;     (defalias #'forward-evil-word #'forward-evil-symbol)
;;     ;; make evil-search-word look for symbol rather than word boundaries
;;     (setq-default evil-symbol-word-search t))
#+END_SRC


See https://www.reddit.com/r/emacs/comments/86iq3w/evil_cw_o_toggle_windows/

#+BEGIN_SRC emacs-lisp
(defun toggle-fullscreen ()
  (interactive)
  (if (window-parent)
      (delete-other-windows)
    (winner-undo)))

(define-key evil-normal-state-map (kbd "C-w o") 'toggle-fullscreen)
#+END_SRC

** Custom Evil keybindings

Emacs provides so many ways to create custom keybindings and to run commands in
general (e.g. emacs key-chords, helm, hydra, evil-leader, etc). You will probably
find multiple shortcuts in this document for executing a same command. One of them
will them will be compatible with my Vim cofiguration which has been wired to my
brain from a decade of using it. The other shortcuts will be more Emacsy.

TODO The question is - should we define them here or within their use-package definitions?

TODO projectile

#+BEGIN_SRC emacs-lisp
(evil-leader/set-key
  "f" 'helm-projectile
  "p" 'helm-projectile-switch-project)
#+END_SRC

Sometimes it happens that ~helm-projectile~ or ~helm-projectile-find-file~
suddenly stops working for a project and nothing (including Emacs restart)
helps. The only solution I accidentally found is running ~helm-ls-git-ls~
command, close it, and then finding files works again.

See https://github.com/emacs-helm/helm-ls-git

TODO magit

#+BEGIN_SRC emacs-lisp
(evil-leader/set-key
  "ga" 'magit-stage-file
  "gc" 'magit-commit  ;; Maybe magit-commit-create
  "gp" 'magit-push-current) ;; @TODO still asks for something, use more specific function
#+END_SRC

Random garbage

#+BEGIN_SRC emacs-lisp
(evil-leader/set-key
  "w" 'evil-window-vsplit
  "def" 'evil-jump-to-tag)
#+END_SRC

** Custom Evil commands

Evil even allows you to create your own colon commands. I don't need it, most folks
probably don't need it, but you got to admit it's pretty spectacular.

See https://emacs.stackexchange.com/questions/10350/how-can-i-add-a-new-colon-command-to-evil

This command is mainly an example how to do it. I have probably never used it.

#+BEGIN_SRC emacs-lisp
(eval-after-load 'evil-ex
  '(evil-ex-define-cmd "Gbrowse" 'browse-at-remote))
#+END_SRC

* Window management

Emacs default window management makes me want to kill myself. After six months,
I still have absolutely no idea how it works. New windows literaly appear on the
least expected positions, they randomly change, some of them even break the
current split configuration. It seems like the internal window manager is trying
so hard to be smart but for me, it has the exactly opposite effect.

Meanwhile, this magic is not necessary (let alone useful) at all. Maybe it is
for vanilla Emacs but in Evil world, the splits and window management is
just amazing.

Let's just open everything in the current window, shall we? I can split manually
if I want to.

We need to configure special buffers separately because it is going to be done
based on ther names. They are special and their names do not change.

For explanation of how ~display-buffer-alist~ works, see
https://www.simplify.ba/articles/2016/01/25/display-buffer-alist/

For other pratical code samples see
https://reflexivereflection.com/posts/2018-04-06-disabling-emacs-window-management.html

#+BEGIN_SRC emacs-lisp
(setq display-buffer-alist
      '(("shell.*" (display-buffer-same-window) ())
        (".*" (display-buffer-reuse-window
               display-buffer-same-window)
         (reusable-frames . t))))
#+END_SRC

The ~display-buffer-alist~ isn't respected by every command, so we need to
specifically set these.

Make sure man pages open in the current window.
See https://stackoverflow.com/a/7787941/3285282

#+BEGIN_SRC emacs-lisp
(setq Man-notify-method 'pushy)
#+END_SRC

* Interface
** GUI

Disable all the GUI nonsense. Even though we are running graphical version of Emacs,
we want to be #mouseless and have the UI to look as close to terminal as possible.

Get rid of menu, scrollbars, toolbars and everything that can be clicked on.

#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(customize-set-variable 'scroll-bar-mode nil)
(customize-set-variable 'horizontal-scroll-bar-mode nil)
#+END_SRC

** Themes

Let's install all the interesting themes.

See http://chriskempson.com/projects/base16/

#+BEGIN_SRC emacs-lisp
(use-package base16-theme
  :ensure t)
#+END_SRC

At this point, my whole desktop environment uses ~base16-chalk~

#+BEGIN_SRC emacs-lisp
(if workstation-p
   (load-theme 'base16-chalk t))
#+END_SRC

** Colors

Let's define our set of colors based on current theme, so we can easily use them
for customizing third-party packages.

See http://chriskempson.com/projects/base16/#styling-guidelines

#+BEGIN_SRC emacs-lisp
(if workstation-p
    (setq my/black (plist-get base16-chalk-colors :base00)
          my/gray (plist-get base16-chalk-colors :base01)
          my/lgray (plist-get base16-chalk-colors :base03)
          ;; ... grayish colors from base02 to base06
          my/white (plist-get base16-chalk-colors :base07)
          my/red (plist-get base16-chalk-colors :base08)
          my/orange (plist-get base16-chalk-colors :base09)
          my/yellow (plist-get base16-chalk-colors :base0A)
          my/green (plist-get base16-chalk-colors :base0B)
          my/lblue (plist-get base16-chalk-colors :base0C)
          my/blue (plist-get base16-chalk-colors :base0D)
          my/purple (plist-get base16-chalk-colors :base0E)
          my/brown (plist-get base16-chalk-colors :base0F)))
#+END_SRC

The custom theme and its colors looks great on my workstation but it won't be
ideal on various systems and devices. Let's define a fallback set of colors
based on the default Emacs theme.

#+BEGIN_SRC emacs-lisp
(if (not workstation-p)
    (setq my/black "black"
          my/gray  "gray75"
          my/lgray "gray60"
          my/white "white"
          my/red "Firebrick"
          my/orange "orange red"
          my/yellow "lightyellow"
          my/green "ForestGreen"
          my/lblue "midnight blue"
          my/blue "blue"
          my/purple "Purple"
          my/brown "brown"))
#+END_SRC

** Fonts

#+BEGIN_SRC emacs-lisp
(set-face-attribute
  'default nil
  :family "vera sans"
  :height 90
  :weight 'normal
  :width 'normal)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'lazy-highlight nil :background my/orange
                                        :foreground my/gray)
#+END_SRC

** Icons and Emojis

Besides normal fonts we also want to setup some icon fonts. Personally, I like
~Font Awesome~ the best. It is really easy to use and it dominates in the realm
of website icons so it is like killing two birds with one stone.

See https://github.com/emacsorphanage/fontawesome

#+BEGIN_SRC emacs-lisp
(use-package fontawesome
  :ensure t)
#+END_SRC

By default ~Font Awesome~ icons show quite strangely. It seems that all icons
work, it's just they are displayed under wrong names. In ~M-x helm-fontawesome~
it works properly though. The following setting fixes it.

See https://github.com/emacsorphanage/fontawesome/issues/12#issuecomment-284193735

Not doing this though because it breaks ~all-the-icons~ filetype icons.

See https://www.reddit.com/r/emacs/comments/pdviti/why_are_alltheicons_displaying_wrong_icons/

#+BEGIN_SRC emacs-lisp
;; (set-fontset-font t 'unicode "FontAwesome" nil 'prepend)
#+END_SRC

The most commonly used collection of icons in Emacs is ~all-the-icons~. It
encapsulates FontAwesome, filetype icons, major mode icons, and more. If the
icons are not displayed correctly, run ~M-x all-the-icons-install-fonts~.

See https://github.com/domtronn/all-the-icons.el

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :ensure t)
#+END_SRC

** Modeline

#+BEGIN_SRC emacs-lisp
(use-package spaceline
  :ensure t
  :config)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package spaceline-config
  :ensure spaceline
  :config
  (spaceline-helm-mode 1)
  (spaceline-spacemacs-theme)
  (spaceline-toggle-org-clock-on)
  (spaceline-toggle-minor-modes-off)
  (spaceline-toggle-version-control-on)
  (spaceline-toggle-buffer-size-off)
  (spaceline-toggle-buffer-encoding-abbrev-off)
  (spaceline-toggle-buffer-position-on))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq spaceline-highlight-face-func 'spaceline-highlight-face-evil-state)
(set-face-attribute 'spaceline-evil-normal nil :background my/gray :foreground my/orange)
(set-face-attribute 'spaceline-evil-emacs nil :background my/gray :foreground my/blue)
(set-face-attribute 'spaceline-evil-insert nil :background my/gray :foreground my/green)
(set-face-attribute 'spaceline-evil-replace nil :background my/gray :foreground my/blue)
(set-face-attribute 'spaceline-evil-motion nil :background my/gray :foreground my/blue)
(set-face-attribute 'spaceline-evil-visual nil :background my/gray :foreground my/purple)
#+END_SRC


See:
- https://dev.to/gonsie/beautifying-the-mode-line-3k10
- https://github.com/TheBB/spaceline/issues/20#issuecomment-150488572

#+BEGIN_SRC emacs-lisp
(spaceline-define-segment version-control
  (when vc-mode
    (let ((gitlogo (replace-regexp-in-string "^ Git." "  " vc-mode)))
      (powerline-raw (s-trim gitlogo)))))
#+END_SRC

After making changes in spaceline segments, it needs to be recompiled, otherwise
they don't take an effect.

#+BEGIN_SRC emacs-lisp
(spaceline-compile)
#+END_SRC

** Helm

#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure t
  :config
  (helm-mode 1)
  (setq helm-autoresize-mode t)
  (setq helm-buffer-max-length 40)
  (setq helm-locate-fuzzy-match t)


  (global-set-key (kbd "M-x") #'helm-M-x)
  ; (define-key helm-map (kbd "S-SPC") 'helm-toggle-visible-mark)
  ; (define-key helm-find-files-map (kbd "C-k") 'helm-find-files-up-one-level)

  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to do persistent action
  (define-key helm-map (kbd "TAB") #'helm-execute-persistent-action)
  (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

  ; http://cachestocaches.com/2016/12/vim-within-emacs-anecdotal-guide/
  (define-key helm-map (kbd "C-j") 'helm-next-line)
  (define-key helm-map (kbd "C-k") 'helm-previous-line)
  (define-key helm-map (kbd "C-h") 'helm-next-source)

  (define-key helm-map [escape] 'helm-keyboard-quit)

  ; (define-key helm-map (kbd "C-S-h") 'describe-key)
  ; (define-key helm-map (kbd "C-l") (kbd "RET"))
  ; (dolist (keymap (list helm-find-files-map helm-read-file-map))
        ; (define-key keymap (kbd "C-l") 'helm-execute-persistent-action)
        ; (define-key keymap (kbd "C-h") 'helm-find-files-up-one-level)
        ; (define-key keymap (kbd "C-S-h") 'describe-key))


)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package helm-posframe
  :ensure t
  :disabled
  :config
  (helm-posframe-enable)
  (setq helm-posframe-poshandler
        #'posframe-poshandler-frame-center)
  (setq helm-posframe-width 200)
  (setq helm-posframe-height 600)
  (setq helm-posframe-parameters
        '((left-fringe . 10)
          (right-fringe . 10))))
#+END_SRC

Unfortunatelly, ~helm-posframe~ is quite buggy and breaks tab-completion for
~M-:~, takes a lot of time to appear, sometimes it appears empty or
whatelse. Let's try to stick with a small helm window at the bottom.

See https://github.com/emacs-helm/helm/issues/2039#issuecomment-390077931

#+BEGIN_SRC emacs-lisp
(defvar spacemacs-helm-display-help-buffer-regexp '("\\*.*Helm.*Help.*\\*"))
(defvar spacemacs-helm-display-buffer-regexp `("\\*.*helm.*\\*"
                                               (display-buffer-in-side-window)
                                               (inhibit-same-window . nil)
                                               (side . bottom)
                                               (window-width . 0.6)
                                               (window-height . 0.6)))

(defun display-helm-at-bottom (buffer &optional _resume)
  (let ((display-buffer-alist (list spacemacs-helm-display-help-buffer-regexp
                                    spacemacs-helm-display-buffer-regexp)))
    (display-buffer buffer)))
(setq helm-display-function 'display-helm-at-bottom)
#+END_SRC

And finally, we want to show a limited number of results.

See https://github.com/emacs-helm/helm/wiki/helm-autoresize

#+BEGIN_SRC emacs-lisp
(helm-autoresize-mode 1)
(setq helm-autoresize-max-height 40)
(setq helm-autoresize-min-height 40)
#+END_SRC

Buffer management is a bread and butter of every text editor. This is true even
more for Emacs because we tend to live in it. Everything is a buffer.
I don't want to navigate through a mess of all things that I've opened this week
every time I want to switch a buffer.

Most times, there is a high probability to guess, what we are currently
interested in. Are we working in a project? Are we in the dired mode? Are we
chatting on IRC?

#+BEGIN_SRC emacs-lisp
(defun my/smart-buffers-list ()
  (interactive)
  (cond ((derived-mode-p 'lui-mode) (my/circe-switch-to-buffer))
        ((projectile-project-root) (helm-projectile-switch-to-buffer))
        (t (helm-buffers-list))))
#+END_SRC

We have a key binding for our smarty-pants buffer-switching command which should
be suitable for 99% of cases and for the rest, there is a fallback showing all
open buffers without any filter.

#+BEGIN_SRC emacs-lisp
(general-nmap ";"  'my/smart-buffers-list)
(general-nmap ",;" 'helm-buffers-list)
#+END_SRC

** Hydra

Hydra, a mythical Greek creature ultimatelly killed by Heracles. The beast
posseses many heads and for every head that is chopped off, Hydra will seal
the wound and grow a two additional heads from it.

What a beautiful /real-life/ example of binary trees. Hydras in Emacs lives
in the same spirit. They are a pop-up menus that you may know from Spacemacs
or Doom Emacs. The menu defines single-letter key bindings that can either
execute a function or spawn another menu.

This has many neat use-cases. You can create menus to simply launch applications,
create a settings menu to easily toggle features (or minor modes), create
shortcuts for commonly used commands, etc.

You can also completly replace all Emacs key bindings because they are allegedly
dangerous for your hands. Let's say that we use space for spawning the hydra
menu. You can implement it in a way, that you can avoid pressing unnecessary
~M-~ and ~C-~ chords (which is actually called ~god-mode~). You might want to
an simpler version of that, e.g.

| Default Chord   | Possible Hydra Alternative |
|-----------------+----------------------------|
| C-a             | <SPC> a                    |
| C-x C-s         | <SPC> xs                   |
| C-a C-k C-n C-y | <SPC> akny                 |

See more about ~god-mode~ https://chrisdone.com/posts/god-mode/

Let's install just the ~hydra~ package and keep it simple.

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :ensure t
  :custom
  (hydra-default-hint nil))
#+END_SRC

Press spacebar to spawn a main hydra window.

#+BEGIN_SRC emacs-lisp
(general-nmap "SPC" 'hydra-main/body)
#+END_SRC

*** Additional Hydra packages

I would really love to use hydra in posframe, but it doesn't work properly

See
- https://github.com/Ladicle/hydra-posframe
- https://github.com/jerrypnz/major-mode-hydra.el/issues/30

#+BEGIN_SRC emacs-lisp
;; (use-package hydra-posframe
;;   :load-path "/home/jkadlcik/git/hydra-posframe"
;;   :hook
;;   (after-init . hydra-posframe-enable))
#+END_SRC

The default way to define hydras is too clumsy and involves a lot of tedious
string formatting by hand. As a consequence it is really painful to add new
items or delete the existing ones. Let's install ~pretty-hydra~ instead,
if allows us to define hydras as lists of columns.

#+BEGIN_SRC emacs-lisp
(use-package pretty-hydra
  :ensure t)
#+END_SRC

*** Main Hydra Menu

Hydra main entry-point allowing us acces to other hydras.

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-main
  (:color blue :quit-key ("q" "SPC") :title "Hydra")
  ("Misc"
   (("m" major-mode-hydra "major mode")
    ("a" hydra-applications/body "applications")
    ("o" browse-url-at-point "open URL")
    ("z" hydra-presentations/body "presentations"))

   "Workspaces"
   (("e" eyebrowse-switch-to-window-config "switch workspace")
    ("E" hydra-eyebrowse/body "eyebrowse"))

   "Projects"
   (("p" helm-projectile-switch-project "switch project")
    ("P" hydra-project/body "projectile"))

   "File Management"
   (("d" dired-jump "open dired in the current directory")
    ("D" hydra-dired/body "dired"))

   "Bookmarks"
   (("B" hydra-bookmarks/body "bookmarks"))

   "Git"
   (("g" magit-status "magit")
    ("G" hydra-magit/body "more magit options"))

   "LSP"
   (("l" hydra-lsp/body "LSP"))

   "Time"
   (("t" org-pomodoro "Pomodoro"))

   "Emacs"
   (("r" (load-file user-init-file) "reload configuration")
    ("h" hydra-help/body "help")
    ("c" hydra-configuration/body "configure"))))
#+END_SRC

TODO define a hydra menu for creating frames (having also specific purpose
     frames such as for IRC, Mail and RSS

*** Help

Hydra definition for documentation and helper functions.

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-help
  (:color blue :quit-key ("q" "SPC") :title "Help")
  ("Help"
   (("h" #'help "help"))

  "Describe"
   (("m" #'describe-mode "mode")
    ("F" #'describe-face "face")
    ("k" #'describe-key "key")
    ("v" #'describe-variable "variable")
    ("f" #'describe-function "function")
    ("c" #'describe-command "command"))))
#+END_SRC

*** Presentations

Hydra definitions useful for presentations.

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-presentations
  (:color blue :quit-key ("q" "SPC") :title "Presentations")
  ("Actions"
   (("l" text-scale-decrease "lesser")
    ("g" text-scale-increase "greated"))))
#+END_SRC

Hydra definitions for ~projectile~ package.

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-project
  (:color blue :quit-key ("q" "SPC") :title "Project Management")
  ("Actions"
   (("d" projectile-discover-projects-in-search-path "discover new projects"))))
#+END_SRC

*** Eyebrowse

Hydra definitions for Eyebrowse commands.

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-eyebrowse
  (:color blue :quit-key ("q" "SPC") :title "Presentations")
  ("Eyebrowse"
   (("e" eyebrowse-switch-to-window-config "Switch to config")
    ("l" eyebrowse-last-window-config "Switch to the latest window config")
    ("c" eyebrowse-create-named-window-config "Create a new config")
    ("r" eyebrowse-rename-window-config "Rename a new config")
    ("d" eyebrowse-close-window-config "Destroy a window config"))))
#+END_SRC

*** Dired

Hydra definition for ~dired~ package.

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-dired
  (:color blue :quit-key ("q" "SPC") :title "Dired")
  ("Open in"
   (("." dired-jump "current directory")
    ("~" (lambda () (interactive) (dired "~/")) "home directory")
    ("/" (lambda () (interactive) (dired "/")) "root directory")
    ("p" (lambda () (interactive) (dired (projectile-project-root)))))))
#+END_SRC

*** Bookmarks

Hydra definition for bookmarks management.

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-bookmarks
  (:color blue :quit-key ("q" "SPC") :title "Bookmarks")
  ("Bookmarks"
   (("c" bookmark-set "Create a bookmark")
    ("l" helm-bookmarks "List and jump bookmarks")
    ("s" bookmark-save "Save bookmarks to disk"))))
#+END_SRC

*** Magit

Hydra definition for ~magit~ package.

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-magit
  (:color blue :quit-key ("q" "SPC") :title "Magit")
  ("Open in"
   (("g" magit-status "magit")
    ("b" magit-branch-checkout))))
#+END_SRC

*** LSP

Hydra definition for ~LSP~.

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-lsp
  (:color blue :quit-key ("q" "SPC") :title "Magit")
  ("Server"
   (("w" lsp-describe-session "Describe session"))

   "Navigation"
   (("d" lsp-find-definition "Jump to definition")
    ("r" lsp-find-references "Find references"))

   "Documentation"
   (("D" lsp-describe-thing-at-point "Show documentation"))

   "Refactoring"
   (("R" lsp-rename "Rename this thing"))

   "Spellcheck"
   (("s" lsp-grammarly-check-grammar "Spellcheck using Grammarly.com")
    ("S" lsp-grammarly-stop "Disable spellcheck"))))
#+END_SRC

*** Flycheck

Hydra definition for flycheck or other linter

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-linter
  (:color blue :quit-key ("q" "SPC") :title "Linter")
  ("Flycheck"
   (("v" flycheck-verify-setup "verify setup")
    ("t" flycheck-mode "toggle on/off"))

   "Error"
   (("<" flycheck-previous-error "previous")
    (">" flycheck-next-error "next")
    ("l" flycheck-list-errors "list")
    ("o" nil "open in browser")
    ("i" pylint-disable-current-warning "ignore"))))
#+END_SRC

*** Applications

Hydra launcher for applications

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-applications
  (:color blue :quit-key ("q" "SPC") :title "Applications")
  ("Launch"
   (("r" elfeed "RSS (elfeed)")
    ("t" frostyx/multi-vterm-named "Terminal (vterm)")
    ("w" eww "web (eww)")
    ("e" mu4e "email (mu4e)")
    ("s" hydra-spotify/body "Spotify"))))
#+END_SRC

*** Configuration

Hydra for configuration/settings/toggle options

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-configuration
  (:color blue :quit-key ("q" "SPC") :title "Configuration")
  ("Vertical Line"
   (("v" turn-off-fci-mode "No vertical line")
    ("6" (my/colorcolumn 60) "60 characters")
    ("7" (my/colorcolumn 70) "70 characters")
    ("8" (my/colorcolumn 80) "80 characters")
    ("1" (my/colorcolumn 100) "100 characters")
    ("2" (my/colorcolumn 120) "120 characters"))))
#+END_SRC

*** Major mode

Thanks to ~major~mode~hydra~ it is possible to easily define
major-mode-specific hydra menus.

See https://github.com/jerrypnz/major-mode-hydra.el

#+BEGIN_SRC emacs-lisp
(use-package major-mode-hydra
  :ensure t)
#+END_SRC

Press Shift+spacebar to spawn a hydra specific to the current major-mode

#+BEGIN_SRC emacs-lisp
(general-nmap "S-SPC" 'major-mode-hydra)
#+END_SRC

**** Org

#+BEGIN_SRC emacs-lisp
(major-mode-hydra-define org-mode
  (:color blue :quit-key ("q" "SPC") :title "Org mode")
  ("Actions"
   (("e" eval-last-sexp "Eval")
    ("t" my/org-todo-done "Mark TODO item as done")
    ("E" org-edit-special "Edit special")
    ("s" org-edit-src-exit "Save special edit"))

   "Navigation"
   (("h" helm-org-in-buffer-headings "Search headers in Helm"))

   "Time"
   (("p" org-pomodoro "Pomodoro"))))
#+END_SRC

**** Python

#+BEGIN_SRC emacs-lisp
(major-mode-hydra-define python-mode
  (:color blue :quit-key ("q" "SPC") :title "Python mode")
  ("Actions"
   (("d" elpy-doc "Show documentation")
    ("l" hydra-linter/body "Linter"))))
#+END_SRC

**** Markdown

#+BEGIN_SRC emacs-lisp
(major-mode-hydra-define markdown-mode
  (:color blue :quit-key ("q" "SPC") :title "Markdown mode")
  ("Actions"
   (("p" markdown-preview "Preview markdown in external web browser"))))
#+END_SRC

**** Elisp

Lisp interaction mode, aka ~*scratch*~ buffer.

#+BEGIN_SRC emacs-lisp
(major-mode-hydra-define (emacs-lisp-mode lisp-interaction-mode)
  (:color blue :quit-key ("q" "SPC") :title "Lisp interaction mode")
  ("Actions"
   (("e" eval-defun "Evaluate this function")
    ("p" eval-print-last-sexp "Evaluate and print to the buffer"))))
#+END_SRC

**** Circe

Hydra menu for Circe IRC client

#+BEGIN_SRC emacs-lisp
(major-mode-hydra-define (circe-channel-mode circe-server-mode circe-query-mode)
  (:color blue :quit-key ("q" "SPC") :title "Circe")
  ("Away"
   (("c" (circe-command-GAWAY nil) "Clear away status")
    ("1" (circe-command-GAWAY "Training, I will be back within two hours") "Gym")
    ("2" (circe-command-GAWAY "I will be back at work in the evening") "Back in the evening")
    ("a" circe-command-GAWAY "Custom away message"))))
#+END_SRC

**** Dired

Hydra menu for Dired file manager

#+BEGIN_SRC emacs-lisp
(major-mode-hydra-define (dired-mode)
  (:color blue :quit-key ("q" "SPC") :title "Dired")
  ("Away"
   (("o" dired-open-file "Open")
    ("v" my/dired-vlc-enqueue "Queue in VLC"))))
#+END_SRC

** Which-key

Nobody can really remember all the Emacs key chords. Let's use
~which-key~ to show us a nice little help once we start some chord and
get stuck remembering how it goes next.

See https://github.com/justbur/emacs-which-key

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :config
  (which-key-mode))
#+END_SRC

* Project management
** Projectile

When working on multiple projects at the same time, it is useful keep some level
of separation between them. This is where ~projectile~ comes handy. It allows you
to easily filter buffers, search files, work with tags and do many more action
within a current project.

As a project is considered every git (or other SCM) repository, or a directory
containing a ~.projectile~ file in it.

See https://github.com/bbatsov/projectile

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :config
  (setq projectile-project-search-path '("~/git/")))
#+END_SRC

TODO Discover projects on startup

The default projectile interface is /meh/ at best, let's use helm.

See https://github.com/bbatsov/helm-projectile

#+BEGIN_SRC emacs-lisp
(use-package helm-projectile
  :ensure t)
#+END_SRC

The only thing that ~projectile~ doesn't allow you to do (at least by default) is
having multiple workspaces/tabs/perspectives or whatever you want to call it and
switching between them. The purpose of such hypothetical workspaces would be to
have one project per workspace that would allow to preserve splits layout when
switching projects. This is essential for me since I work on 5-10 projects
simultaneously.

Such behavior can be achieved using ~eyebrowse~ even though it feels a little
like a workaround. Eyebrowse is not project-oriented by design, it gives you
free hand on what to use workspaces for. For this reason, it lacks certain
project management shortcuts, that I would appreciate.

** Eyebrowse

See https://github.com/wasamasa/eyebrowse

#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :ensure t
  :config
  (eyebrowse-mode t)
  (eyebrowse-setup-opinionated-keys)

  ;; unmap `gc' because it conflicts with `evil-commentary'
  :bind
  (:map evil-normal-state-map
     ("g c" . nil)

   :map evil-motion-state-map
     ("g c" . nil)))
#+END_SRC

Besides hydra, I sometimes use leader key for quickly switching between
eyebrowse workspaces.

#+BEGIN_SRC emacs-lisp
(evil-leader/set-key
  "e" 'eyebrowse-switch-to-window-config)
#+END_SRC

When creating a new workspace do not copy the current window layout to it. I
will most likely want only a single window there and split it only when
necessary. This cryptic option means - Create a new workspace with just
~*scratch*~ buffer.

#+BEGIN_SRC emacs-lisp
(setq eyebrowse-new-workspace t)
#+END_SRC

My workflow for opening a new project is.

1. Create a new named workspace ~SPC E c~
2. Switch to the desired project ~SPC p~

Have some backups of Eyebrowse configurations in case Emacs crashes.

#+BEGIN_SRC emacs-lisp
(use-package eyebrowse-restore
  :ensure t
  :quelpa (eyebrowse-restore
           :fetcher github
           :repo "FrostyX/eyebrowse-restore"
           :branch "main")
  :config
  (eyebrowse-restore-mode))
#+END_SRC

* Sessions

With Emacs, the idea is to launch it, use it and then never ever close it. Basically
just become one with it and let it consume you. The problem is that sometimes we
just don't have another option than to close it (laptop battery can run out, power
outages, system reboots). All of these sucks by themselves but they can be particularly
painful when hundreds days long Emacs session gets killed and you are forced to start
from scratch.

For this reason, we want to save a current session when closing Emacs and restore it
when launching it. Additionally we want to periodically save the current session to
prevent its lose in more violent situations than ~SIGTERM~.

See https://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Emacs-Sessions.html

#+BEGIN_SRC emacs-lisp
(desktop-save-mode 1)
#+END_SRC

The periodical save is achieved by ~auto-save-*~ settings as a "side effect".

To preserve even splits layout when restoring Emacs from a previous session,
we need to explicitly load saved frameset from ~desktop-saved-frameset~

See https://emacs.stackexchange.com/a/45829

#+BEGIN_SRC emacs-lisp
(setq desktop-restore-forces-onscreen nil)
(add-hook 'desktop-after-read-hook
 (lambda ()
   (frameset-restore
    desktop-saved-frameset
    :reuse-frames (eq desktop-restore-reuses-frames t)
    :cleanup-frames (not (eq desktop-restore-reuses-frames 'keep))
    :force-display desktop-restore-in-current-display
    :force-onscreen desktop-restore-forces-onscreen)))
#+END_SRC

This approach is able to correctly save and restore even ~eyebrowse~ workspaces.

* Upkeep

Since we are running Emacs for months and months without closing, and even if we
do, we restore the whole previous session, it is a good idea to make sure, that
it doesn't waste resources by remembering things that are not necessary.

Midnight mode runs a configured set of actions every /midnight/. By default it
closes every buffer that hasn't been visited in last 3 days.

See https://www.emacswiki.org/emacs/MidnightMode

#+BEGIN_SRC emacs-lisp
(use-package midnight
  :ensure t
  :disabled
  :config
  (midnight-mode))
#+END_SRC

Unforunatelly my hack for not-killing eyebrowse-visible buffers (see
further bellow) stopped working so I need to have ~midnight-mode~
temporarily disabled.

My midnight is definitelly not at midnight because I am definitely up and
working at that time. It is safer to run automaticall tasks early in the
morning.

#+BEGIN_SRC emacs-lisp
(midnight-delay-set 'midnight-delay "4:30am")
#+END_SRC

Never kill circe buffers.

#+BEGIN_SRC emacs-lisp
(defun my/buffer-is-circe-p (buffer-name)
  (with-current-buffer buffer-name
    (derived-mode-p 'lui-mode)))
#+END_SRC

Never kill buffers that are currently /visible/ in any of eyebrowse window
layouts. For that we first need to figure out what buffers are visible
eyebrowse-wide.

#+BEGIN_SRC emacs-lisp
(defun my/eyebrowse-all-buffer-names ()
  (let ((buffer-names (list)))
    (dolist (window-config (eyebrowse--get 'window-configs))
      (eyebrowse--walk-window-config
       window-config
       (lambda (item)
         (when (eq (car item) 'buffer)
           (let ((buffer-name (cadr item)))
             (add-to-list 'buffer-names buffer-name))))))
    buffer-names))
#+END_SRC

And now we can make a predicate to see if some buffer is visible within any
eyebrowse layout.

#+BEGIN_SRC emacs-lisp
(defun my/buffer-is-eyebrowse-visible-p (buffer-name)
  (seq-contains (my/eyebrowse-all-buffer-names) buffer-name))
#+END_SRC

The name ~clean-buffer-list-kill-never-regexps~ is quite confusing because
besides regexps it accepts also funcitons. See documentation for more info but
basically the function takes a buffer name as an argument and returns non-nil
when the buffer should never be killed.

#+BEGIN_SRC emacs-lisp
(setq clean-buffer-list-kill-never-regexps
      (list 'my/buffer-is-circe-p
            'my/buffer-is-eyebrowse-visible-p))
#+END_SRC

* Development

#+BEGIN_SRC emacs-lisp
(use-package fic-mode
  :ensure t
  :config
  (add-hook 'prog-mode-hook 'fic-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  ;; There is a bug visualizing even #def in .Xdefaults
  :ensure t
  :config
  nil)
#+END_SRC

In many programming languages there is a standard line width and code should not
continue over it. Also when writting a text (e.g. documentation) it is better to
hard-wrap the lines somewhere. It makes a review easier, it is much clearer in
diffs, ets. Typically we wrap at 80, 100 or 120 characters.

#+BEGIN_SRC emacs-lisp
(use-package fill-column-indicator
  :ensure t
  :config
  (setq fci-rule-width 1)
  (setq fci-rule-color my/gray))
#+END_SRC

Let's define a function which will color a given column

#+BEGIN_SRC emacs-lisp
(defun my/colorcolumn (column)
  (turn-on-fci-mode)
  (set-fill-column column))
#+END_SRC

It is often useful to open the currently viewed buffer or lines selection in the
web browser.

See https://github.com/rmuslimov/browse-at-remote
Also see my blog post http://frostyx.cz/posts/emacs-browse-at-pagure

#+BEGIN_SRC emacs-lisp
(use-package browse-at-remote
  :ensure t)
#+END_SRC

** Indentation

Disable ~electric-indent-mode~ because it is trying to be smart and do weird
aggressive indents that are in fact just stupid and only makes me manually remove
and adjust them. Also make sure, that any major mode won't turn it on again.

#+BEGIN_SRC emacs-lisp
(electric-indent-mode -1)
(add-hook 'after-change-major-mode-hook (lambda() (electric-indent-mode -1)))
#+END_SRC

By default, use spaces, not tabs

#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

Set tab width and other indentation settings based on the analysis of the
current project.

#+BEGIN_SRC emacs-lisp
(use-package dtrt-indent
  :ensure t
  :config
  (dtrt-indent-global-mode)
  (dtrt-indent-adapt))
#+END_SRC

Map ~ENTER~ key to execute ~newline-and-indent~ in order to eliminate different
indentation from ~ENTER~ and pressing Evil ~o~ command. Hopefully they are the
same, we need some longer observation.

TODO map this for all modes?

#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "RET") 'newline-and-indent)
#+END_SRC

In case a project uses TABs for indenting, we want to see them with some
reasonable size.

#+BEGIN_SRC emacs-lisp
(setq tab-width 4)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun hook-tab-width ()
  (setq tab-width 4)
  (setq evil-shift-width 4)
  (setq python-indent-offset 4))
(add-hook 'prog-mode-hook #'hook-tab-width)
#+END_SRC

We need to adjust tab width for Evil ~<<~ and ~>>~ separately.

#+BEGIN_SRC emacs-lisp
(setq evil-shift-width 4)
#+END_SRC

And lastly, we need to adjust tab width for indenting using ~TAB~ key.

#+BEGIN_SRC emacs-lisp
(setq python-indent-offset 4)
#+END_SRC

** Completion

Our completion framework of choice is ~company~.

See https://company-mode.github.io/

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :hook
  (company-mode . frostyx/company-mode-hook))
#+END_SRC

When ~company-mode~ is activated for a buffer, use do some
configuration, such as, changing ~C-n~ to use it. Also automatically
insert candidates while ~C-n~ and ~C-p~ through them.

#+BEGIN_SRC emacs-lisp
(defun frostyx/company-mode-hook ()
  (setq-local evil-complete-next-func 'frostyx/company-complete))
#+END_SRC

Unfortunatelly we cannot use the default ~company-complete~ because it
takes no arguments.

#+BEGIN_SRC emacs-lisp
(defun frostyx/company-complete (&optional arg)
  (interactive)
  (company-complete-common-or-cycle))
#+END_SRC

For the love of god, be case-sensitive. This setting IMHO applies only
to plain text completions.

#+BEGIN_SRC emacs-lisp
(setq company-dabbrev-ignore-case nil)
(setq company-dabbrev-downcase nil)
#+END_SRC

Make the icons less disruptive and cooler

#+BEGIN_SRC emacs-lisp
(setq company-icon-margin 3)
#+END_SRC

Automatically insert candidates while ~C-n~ and ~C-p~ through them.

#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook 'company-tng-mode)
#+END_SRC

We need to turn off the auto configuration because it messes up with
brackets. But now we need to remap the ~company-active-map~ manually
otherwise pressing ~RET~ without selecting a candiate does nothing
(instead of simply inserting a new line)

#+BEGIN_SRC emacs-lisp
(setq company-tng-auto-configure nil)
(with-eval-after-load 'company-tng
  (setq company-active-map company-tng-map))
#+END_SRC

Use ~company-mode~ everywhere

#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook 'global-company-mode)
#+END_SRC

** Whitespace

#+BEGIN_SRC emacs-lisp
;; @TODO try this after restarting emacs
;; https://stackoverflow.com/questions/15946178/change-the-color-of-the-characters-in-whitespace-mode
;; (setq whitespace-display-mappings
;;   ;; all numbers are Unicode codepoint in decimal. ⁖ (insert-char 182 1)
;;   '(
;;     (space-mark 32 [183] [46]) ; 32 SPACE 「 」, 183 MIDDLE DOT 「·」, 46 FULL STOP 「.」
;;     (newline-mark 10 [182 10]) ; 10 LINE FEED
;;     (tab-mark 9 [9655 9] [92 9]) ; 9 TAB, 9655 WHITE RIGHT-POINTING TRIANGLE 「▷」
;;     ))
#+END_SRC

Just remove all trailing whitespace on save. This can be annoying when somebody else already
messed it up and commited to git repo with trailing spaces but overall its the most comfortable
option.

#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'unix-newline)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** Version control

Sometimes it might be useful to visualize git changes within a file
(new and changed lines).

Use ~M-x diff-hl-mode~

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :ensure t)
#+END_SRC

** Flycheck

It is handy to have some on-fly syntax and style checker in order to not
produce ugly code.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t)
#+END_SRC

Such tools are typically slow on large files, so to make it (allegedly 10x)
faster, do not highlight words, but rather lines.

#+BEGIN_SRC emacs-lisp
(setq flycheck-highlighting-mode 'lines)
#+END_SRC

Argh, by default flycheck and other tools are so aggressive and distracting
with all the text underlines and other annoying things.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'flycheck-info nil :underline nil)
(set-face-attribute 'flycheck-warning nil :underline nil)
(set-face-attribute 'flycheck-error nil :underline nil)
#+END_SRC

It is not 1970s and we don't use computer terminals with 80x24 characters
resolution anymore. Line length of 120 characters is reasonable enough.

#+BEGIN_SRC emacs-lisp
(setq-default flycheck-flake8-maximum-line-length 120)
#+END_SRC

TODO from below this point, the flycheck configuration is python-specific

Flycheck allows to run only one checker at the time. However, it allows to
chain then and run them sequentially. In this case, after running flake8,
run also a pylint.

#+BEGIN_SRC emacs-lisp
(flycheck-add-next-checker 'python-flake8 'python-pylint)
#+END_SRC

We would like to see symbolic, human readable IDs like ~no-name-in-module~
instead of numeric values like ~E0611~. However, columns width in
~M-x flycheck-list-errors~ are fixed and hardcoded, so just use numbers.

#+BEGIN_SRC emacs-lisp
(setq-default flycheck-pylint-use-symbolic-id nil)
#+END_SRC

Define a function to convert numeric error ID to symbolic.

#+BEGIN_SRC emacs-lisp
(defun pylint-id-to-symbolic (msg-id)
  (let* ((cmd (list "pylint" "--help-msg" msg-id))
         (msg (shell-command-to-string (combine-and-quote-strings cmd)))
         (start (+ (string-match ":" msg) 1))
         (end (string-match ":" msg start))
         (name (substring msg start end)))
    (car (split-string name " "))))
#+END_SRC

We can now disable false positive errors with a symbolic ID

#+BEGIN_SRC emacs-lisp
(defun pylint-disable-warning (msg-id)
  (end-of-line)
  (insert "  " (format "# pylint: disable=%s" msg-id)))
#+END_SRC

Get pylint error ID for the current line

TODO it would be better to have universal ~pylint-error-on-line~ so it easier
to test and then specify line number in ~pylint-disable-current-warning~.

#+BEGIN_SRC emacs-lisp
(defun pylint-current-error ()
  (first (flycheck-overlay-errors-at (point))))
#+END_SRC

Glue everything together in one function to disable pylint warning
for the current line.

See https://www.reddit.com/r/emacs/comments/g31gtn/generate_comment_to_disable_falsepositive_pylint/

#+BEGIN_SRC emacs-lisp
(defun pylint-disable-current-warning ()
  (interactive)
  (pylint-disable-warning
    (pylint-id-to-symbolic
      (flycheck-error-id
        (pylint-current-error)))))
#+END_SRC

** Snippets

It is so boring to type the same things again and again and again,
every day, hundred times a day. I've written the line
~import ipdb; ipdb.set_trace()~ literaly a ten thousand times in my life.
Let's install ~yasnippet~ so we can do just ~ipdb<TAB>~.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :init
  (yas-global-mode 1))
#+END_SRC

By default the snippet manager doesn't come with any snippets. Which is
good idea but we don't really want to write all snippets on our own,
it is a big maintanance overhead. Let's install some snippets collection
and then write/override whatever is needed.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet-snippets
  :ensure t)
#+END_SRC

Specify paths to snippets and reload all of them

#+BEGIN_SRC emacs-lisp
(setq yas-snippet-dirs
      (list (expand-file-name "snippets/" user-emacs-directory)
            yasnippet-snippets-dir))
(yas-reload-all)
#+END_SRC

You can find my custom snippets in ~./snippets/~ directory. When creating
a new snippet, just run ~M-x yas-new-snippet~ and then save it simply as
~:w keyname~. It will store it to an appropriate directory for the current
major mode.

See ~M-x yas-describe-tables~ for all available snippets.

** Languages
*** Python

#+BEGIN_SRC emacs-lisp
(frostyx/dnf :install "python3-virtualenv")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package elpy
  :ensure t
  :disabled t
  :init
  ;; @TODO have some module for snippets
  (setq elpy-modules
        '(elpy-module-sane-defaults
          elpy-module-company
          elpy-module-eldoc
          elpy-module-yasnippet
          elpy-module-django))
  (elpy-enable))
#+END_SRC

Use flycheck instead of flymake

See https://elpy.readthedocs.io/en/latest/customization_tips.html#use-flycheck-instead-of-flymake

#+BEGIN_SRC emacs-lisp
(add-hook 'elpy-mode-hook 'flycheck-mode)
#+END_SRC

*** Lisp

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :config
  (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode))
#+END_SRC

*** Elm

Elm command line tools (such as ~elm-format~) are not properly packaged in Fedora,
so we need to install them using ~npm~.

#+BEGIN_SRC bash
npm install elm
npm install elm-format
npm install elm-test
#+END_SRC

Extend ~$PATH~ so Emacs can use them.

#+BEGIN_SRC emacs-lisp
(add-to-list 'exec-path (expand-file-name "~/node_modules/.bin"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package elm-mode
  :ensure t
  :config
  (add-hook 'elm-mode-hook 'elm-format-on-save-mode))
#+END_SRC

*** Haskell

Nope, I don't know haskell. I successfully fail learning it every time. Au
revoir Haskell, see you again later this year. Every year.

#+BEGIN_SRC emacs-lisp
(use-package haskell-mode
  :ensure t)
#+END_SRC

*** Jinja2

#+BEGIN_SRC emacs-lisp
(use-package jinja2-mode
  :ensure t)
#+END_SRC

*** Org

Hint: see Org-Mode Reference Card
https://www.gnu.org/software/emacs/refcards/pdf/orgcard.pdf

Hint: see straightforward, yet comprehensive Org-Mode manual
http://doc.norang.ca/org-mode.html

Every larger document that is trying to look professionally should have
a table of contents. Don't try to maintain it manually, it is the first
step towards insanity. Use ~toc-org~ package instead.

#+BEGIN_SRC emacs-lisp
(use-package toc-org
  :ensure t
  :after org)
#+END_SRC

Now you can put ~:TOC:~ tag to a heading, run ~M-x toc-org-insert-toc~
to generate the initial version based on your document structure and
after this, every time you change the structure and save the document,
TOC will be regenerated.


#+BEGIN_SRC emacs-lisp
(setq org-src-window-setup 'current-window)
(setq org-src-preserve-indentation nil)
(setq org-edit-src-content-indentation 0)
#+END_SRC

See https://stackoverflow.com/a/24173780/3285282

#+BEGIN_SRC emacs-lisp
;; @FIXME doesn't seem to work for GitHub
(setcar (nthcdr 2 org-emphasis-regexp-components) " \t\r\n\"'")
(org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components)
#+END_SRC

I use checklists on a daily basis and often they get quite long. Additionally,
I don't always process them from the beginning to the end but rather randomly,
they are not numbered, so what. Then it can become quite messy when the
completed items are not grayed out. This fixes it.

See https://fuco1.github.io/2017-05-25-Fontify-done-checkbox-items-in-org-mode.html

#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
 'org-mode
 `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:X\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)" 1 'org-headline-done prepend))
 'append)
#+END_SRC

The ~org-headline-done prepend~ face has by default some weird color. It should
be gray ... I mean, we don't say /grayed out/ for no reason.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'org-headline-done nil :foreground my/lgray)
#+END_SRC

Show agendas from these TODO files.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-files '("~/Org/gtd/inbox.org"
                         "~/Org/gtd/gtd.org"
                         "~/Org/gtd/tickler.org"))
#+END_SRC

For the love of god, do not do ~\'reorganize-frame~, nor any other shenanigans.
Why can't Emacs let me do my window management manually instead of trying to
convince applications to behave more friendly one by one.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-window-setup 'current-window)
#+END_SRC

I find the default agenda view too cluttered. Let's install ~org-super-agenda~
which allows us to easily show custom groups of tasks (and display them in
prettified as we want to).

See https://github.com/alphapapa/org-super-agenda

#+BEGIN_SRC emacs-lisp
(use-package org-super-agenda
  :ensure t
  :config
  (org-super-agenda-mode))
#+END_SRC

TODO this is my WIP implementation of super agenda

#+BEGIN_SRC emacs-lisp
(defun my/org-agenda-group-name (icon name)
  (concat
   (propertize (fontawesome icon)
               'face '(:family "FontAwesome"))
   " "
   name))

(defun my/org-agenda ()
  (interactive)
  (let ((org-agenda-span 'day)
	(org-super-agenda-groups
	 `((:name ,(my/org-agenda-group-name "star-o" "Next")
		  :todo "NEXT")

	   (:name ,(my/org-agenda-group-name "flash" "Important")
		  :priority "A")

	   (:name ,(my/org-agenda-group-name "thumb-tack" "Started")
		  :todo "STARTED")

	   (:name ,(my/org-agenda-group-name "clock-o" "Waiting")
		  :todo "WAITING")

	   (:name ,(my/org-agenda-group-name "check-square-o" "TODO")
		  :todo "TODO")

	   (:name ,(my/org-agenda-group-name "exclamation-triangle" "Blocked")
		  :todo "BLOCKED")

	   ;; TODO ideally show finished tasks as a motivation that
	   ;; things are being done
	   (:todo ("DONE" "CANCELLED")))))
    (org-todo-list)))
#+END_SRC

The sequence of possible states for our TODO items. These are just basic ones, I
am trying to keep this sequence as limited as possible. However, in case we need
more complicated state management, we can add another sequences. This can be
useull e.g. for tracking bugs, Trello, JIRA, etc.

See https://orgmode.org/manual/Multiple-sets-in-one-file.html#Multiple-sets-in-one-file

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t)"
                  "NEXT(n)"
                  "STARTED(s)"
                  "WAITING(w)"
                  "BLOCKED(b)"
                  "|"
                  "DONE(d)"
                  "CANCELLED(c)")))
#+END_SRC

There are multiple ways to change a state of a TODO item under the cursor, but
all of them are unnecessarily complicated for simply completing the items (which
is the case 90% of times). We can use ~C-c C-t~ to select and switch a new
state, or ~S-RIGHT S-LEFT~ to move in the sequence of states.

See https://orgmode.org/manual/TODO-Basics.html

Let's just have a function to switch TODO item into ~DONE~ state.

#+BEGIN_SRC emacs-lisp
(defun my/org-todo-done ()
  (interactive)
  (org-todo 'done))
#+END_SRC

@TODO Make a helm interface for ~C-c C-t~

When a TODO item is completed, automatically insert a timestamp.

#+BEGIN_SRC emacs-lisp
(setq org-log-done 'time)
#+END_SRC

This is not a piece of configuration but I tend to forget key bindings. It is
possible to schedule a TODO item by pressing ~C-c C-s~. Use shift + arrow keys
to move between dates and time optionally is typed in a prompt.

See https://orgmode.org/manual/The-date_002ftime-prompt.html

Similarly, a deadline can be set by pressing ~C-c C-d~.

See https://orgmode.org/manual/Inserting-deadline_002fschedule.html

Let's have more colorful TODO keywords

#+BEGIN_SRC emacs-lisp
(setq org-todo-keyword-faces
      `(("TODO"      . (:foreground ,my/red))
        ("NEXT"      . (:foreground ,my/red))
        ("STARTED"   . (:foreground ,my/yellow))
        ("WAITING"   . (:foreground ,my/lblue))
        ("BLOCKED"   . (:foreground ,my/red))
        ("DONE"      . (:foreground ,my/green))
        ("CANCELLED" . (:foreground ,my/green))))
#+END_SRC

TODO org-capture

#+BEGIN_SRC emacs-lisp
(setq org-default-notes-file (concat org-directory "/gtd/inbox.org"))
#+END_SRC

TODO Capture templates for adding TODOs via ~org-agenda~

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
      '(("t" "Todo" entry (file+olp "~/org/gtd/gtd.org" "2020" "Week 45")
         "* TODO %?\n  %i\n  %a")
        ("i" "Inbox" entry (file+headline "~/org/gtd/inbox.org" "Tasks")
         "* TODO %?\n  %i\n  %a")))
#+END_SRC

Install helm support for Org files. The main feature is
~helm-org-in-buffer-headings~ that provides a navigation based on header names.

See https://github.com/emacs-helm/helm-org

#+BEGIN_SRC emacs-lisp
(use-package helm-org
  :ensure t)
#+END_SRC

Show breadcrumbs for each heading, see more eplanation here
https://github.com/emacs-helm/helm-org/issues/27

#+BEGIN_SRC emacs-lisp
(setq helm-org-format-outline-path t)
#+END_SRC

**** Pomodoro
The Pomodoro Technique is a time management technique that uses a timer to break
work into short intervals (typically 25 minutes of work followed by 5 minutes of
rest).

See https://todoist.com/productivity-methods/pomodoro-technique
See a simple pomodoro timer in the web browser https://pomofocus.io/

Of course, we want to use Emacs and ~org-mode~.

#+BEGIN_SRC emacs-lisp
(use-package org-pomodoro
  :ensure t)
#+END_SRC

For some strange reason, stopping the pomodoro timer prematurely throws away the
record about working on that, as if we did nothing. That's just wrong, we want
to keep them.

#+BEGIN_SRC emacs-lisp
(setq org-pomodoro-keep-killed-pomodoro-time t)
#+END_SRC

Let's have pretty strings in the modeline.

#+BEGIN_SRC emacs-lisp
(setq org-pomodoro-format " %s")
(setq org-pomodoro-short-break-format " Short Break %s")
(setq org-pomodoro-long-break-format " Long Break %s")
#+END_SRC

Remove the ugly formatting of a task name.

#+BEGIN_SRC emacs-lisp
(defun my/org-clock-get-clock-string ()
  (concat " " org-clock-heading))

(setq spaceline-org-clock-format-function 'my/org-clock-get-clock-string)
#+END_SRC

And let's have also pretty colors in the modeline.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'org-pomodoro-mode-line nil :foreground my/green)
(set-face-attribute 'org-pomodoro-mode-line-overtime nil :foreground my/red)
#+END_SRC

Initially the idea of having sounds alerts enabled was just
repuslive. Everything on my system is supposed to just shut the fuck up and
doesn't interupt my music. On the other hand, the possibility of having Abathur
saying "Must continue work" and "Terminated" is dope. Let's do that.

#+BEGIN_SRC emacs-lisp
(setq org-pomodoro-start-sound-p t)
(setq org-pomodoro-finished-sound-p t)
#+END_SRC

I downloaded Abathur voice lines from here
https://heroesofthestorm.fandom.com/wiki/Abathur/Quotes

They come in the ~ogg~ format, which is not supported by ~org-pomodoro~. You can
convert them into ~wav~ like this.

#+BEGIN_SRC bash
ffmpeg -i AbathurHero_Revive02.ogg AbathurHero_Revive02.wav
#+END_SRC

Use our custom voice lines.

#+BEGIN_SRC emacs-lisp
(setq org-pomodoro-start-sound
      "/home/jkadlcik/.emacs.d/audio/AbathurHero_Revive02.wav")

(setq org-pomodoro-finished-sound
      "/home/jkadlcik/.emacs.d/audio/AbathurHero_Kill04.wav")
#+END_SRC

If something goes wrong, you can test the sounds with

#+BEGIN_SRC lisp
(org-pomodoro-play-sound :start)
#+END_SRC

Ah, chills.

#+BEGIN_SRC emacs-lisp
(setq org-pomodoro-short-break-sound-p nil)
(setq org-pomodoro-long-break-sound-p nil)

(setq org-pomodoro-length 30)
(setq org-pomodoro-short-break-length 0)
(setq org-pomodoro-long-break-length 0)
(setq org-pomodoro-long-break-frequency 1)
(setq org-pomodoro-expiry-time 30)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my/org-pomodoro ()
  (interactive)
  (org-pomodoro '(4)))
#+END_SRC

*** Markdown

For previews, we need an external command.
The ~discount~ is a weird name but it in fact provides ~/usr/bin/markdown~
command.

#+BEGIN_SRC emacs-lisp
(frostyx/dnf :install "discount")
#+END_SRC

See https://stackoverflow.com/a/34672923/3285282

#+BEGIN_SRC emacs-lisp
(defadvice markdown-preview (around markdown-preview-in-chromium activate compile)
   (let ((browse-url-browser-function #'browse-url-chromium))
     ad-do-it))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq browse-url-chromium-program "google-chrome")
#+END_SRC

*** Ascii doc

Just some syntax highlighting for asciidoc manual pages.

#+BEGIN_SRC emacs-lisp
(use-package adoc-mode
  :ensure t)
#+END_SRC

*** RPM spec

Install a package with support for RPM packaging and writing ~.spec~ files.
Besides other things, it provides a template for creating a new spec files.
Just use ~:e ~/rpmbuild/SPECS/foo.spec~ to use it.

#+BEGIN_SRC emacs-lisp
(use-package rpm-spec-mode
  :ensure t)
#+END_SRC

By default the ~rpm-spec-mode~ is not matched with ~.spec~ files, so they are
still automatically opened with ~shell-script-mode~. We need to configure this
to use ~rpm-spec-mode~ instead.

#+BEGIN_SRC emacs-lisp
(setq auto-mode-alist
      (append '(("\\.spec" . rpm-spec-mode))
       auto-mode-alist))
#+END_SRC

The ~rpm-spec-mode~ provides real nice syntax highlighting but unfortunatelly
it uses just straight-horrible colors to do so. Use something more consistent
with the rest of our theme.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'rpm-spec-tag-face nil :foreground my/blue)
(set-face-attribute 'rpm-spec-obsolete-tag-face nil :foreground my/red)
(set-face-attribute 'rpm-spec-macro-face nil :foreground my/yellow)
(set-face-attribute 'rpm-spec-var-face nil :foreground my/red)
(set-face-attribute 'rpm-spec-doc-face nil :foreground my/purple)
(set-face-attribute 'rpm-spec-dir-face nil :foreground my/green)
(set-face-attribute 'rpm-spec-package-face nil :foreground my/red)
(set-face-attribute 'rpm-spec-ghost-face nil :foreground my/red)
(set-face-attribute 'rpm-spec-section-face nil :foreground my/yellow)
#+END_SRC

TODO it uses tabs! Don't use tabs for god sake

*** PlantUML

PlantUML is a language for describing UML diagrams such as Sequence
diagram, Usecase diagram, Class diagram, Activity diagram, etc. Bye
bye slow, ugly, and annoying UML editors.

See https://plantuml.com/

In Emacs, we have ~plantuml-mode~. It even provides previews with
~C-c C-c~.

See https://github.com/skuro/plantuml-mode

#+BEGIN_SRC emacs-lisp
(use-package plantuml-mode
  :ensure t)
#+END_SRC

Don't forget to install the ~plantuml~ package.

#+BEGIN_SRC emacs-lisp
(frostyx/dnf :install "plantuml")
#+END_SRC

Use the binary provided by Fedora

#+BEGIN_SRC emacs-lisp
(setq plantuml-executable-path "/usr/bin/plantuml")
(setq plantuml-default-exec-mode 'executable)
#+END_SRC

** LSP

See https://emacs-lsp.github.io/lsp-mode/

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode
  :ensure t
  :commands (lsp lsp-deferred)
  :hook
  (python-mode . lsp-deferred)
  (markdown-mode . lsp-deferred)
  :init
  (setq lsp-keymap-prefix "C-c l"))
#+END_SRC

Hide the ugly header navigation that comes with the default ~lsp-mode~
package.

#+BEGIN_SRC emacs-lisp
(setq lsp-headerline-breadcrumb-enable nil)
#+END_SRC

The documentation pop-ups at the bottom are too annoying, disable them. Don't
worry, this will still show single line with signatures below the modeline.

#+BEGIN_SRC emacs-lisp
(setq lsp-signature-render-documentation nil)
#+END_SRC

Highlighting all occurences of thing under cursor is useful but
please, do not underline it.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'lsp-mode
  (set-face-attribute 'lsp-face-highlight-read nil :underline nil))
#+END_SRC

Don't auto-complete function arguments in Company. Its implemented via
snippets and therefore takes over and provides jumping between
arguments and stuff. It's too annoying.
The problem with disabling this feature is that (at least in
combination with ~company-tng-mode~ it now auto-completes functions
without parentheses. Therefore, after selecting the correct function
using ~C-n~ and ~C-p~, the next pressed key must be opening bracket
~(~ instead of ~SPC~, ~TAB~, ~RET~, or whatever.

#+BEGIN_SRC emacs-lisp
(setq lsp-enable-snippet nil)
#+END_SRC

*** Python

See https://emacs-lsp.github.io/lsp-mode/page/languages/
See https://github.com/palantir/python-language-server

#+BEGIN_SRC emacs-lisp
(frostyx/dnf :install "python3-language-server")
#+END_SRC

The python language server shows deprecation warnings, I hope this is
going to be fixed in a new Fedora, otherwise we would have to do
something about it.

*** Grammarly

For some reason ~lsp-grammarly~ requires this ~keytar~ thing and for
some other reason, it doesn't pull it automatically as a dependency.

#+BEGIN_SRC emacs-lisp
(use-package keytar
  :ensure t)
#+END_SRC

It requires a Javascript package installed via ~npm~.
TODO Package it for Fedora as a RPM

#+BEGIN_SRC emacs-lisp
(keytar-install)
#+END_SRC

Now we can finally install the ~lsp-grammarly~ package.

See https://github.com/emacs-grammarly/lsp-grammarly

For the first time, you need to manually log-in to your Grammarly
account. If I understand this properly, the credentials will then be
stored to ~keytar~ and preserved after closing Emacs.

#+BEGIN_SRC emacs-lisp
(use-package lsp-grammarly
  :ensure t)
#+END_SRC

*** Docker

Install syntax highlighting for dockerfiles

#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :ensure t)
#+END_SRC

* Writing

First see some cool writing setups from other people:

- https://explog.in/notes/writingsetup.html

When coding, we want to be in a full control of line wrapping and their lengths,
so seeing a vertical ruler and wrapping them manually is ideal. However, when
writing text, it is more of a drag. Let's just hard-wrap all lines automatically
on 80 characters.

#+BEGIN_SRC emacs-lisp
(setq fill-column 80)
(add-hook 'org-mode-hook 'turn-on-auto-fill)
(add-hook 'markdown-mode-hook 'turn-on-auto-fill)
(add-hook 'rst-mode-hook 'turn-on-auto-fill)
(add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; @TODO don't modify modeline
(setq writeroom-fullscreen-effect (quote maximized))
(add-hook 'writeroom-mode-hook
        (lambda ()
          (if writeroom-mode
              (progn
                (blink-cursor-mode 0)  ; turn off blinky cursor
                (fringe-mode 0)  ; hide fringes
                (setq-local inhibit-message t))  ; don't distract
            (progn
              (blink-cursor-mode t)
              (fringe-mode nil)
              (setq-local inhibit-message t)))))


(set-face-attribute 'line-number-current-line nil
  :inverse-video nil
  ;https://github.com/belak/base16-emacs/commit/f701a8e191ae9c0bd6ab93926ce993bb18a9e98c
  ; :foreground "base03"
  ; :background "base01")
)
#+END_SRC

* Documents
** Man pages

The ~M-x man~ doesn't apply faces that well, see e.g. wrong rendering in
~M-x man mock~. Let's use default colors and use it only as a fallback
tool. Instead, let's use ~M-x woman~.

#+BEGIN_SRC emacs-lisp
(use-package woman
  :ensure t)
#+END_SRC

And set some pretty colors

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'woman-bold nil :foreground my/blue)
(set-face-attribute 'woman-italic nil :foreground my/orange)
(set-face-attribute 'woman-unknown nil :foreground my/red)
#+END_SRC

* Applications

If I shoot myself into my leg and accidentally break a buffer by running an
application in it and panicking how to get back, just kill the buffer with
~M-x kill-buffer~.

** Magit
Magit is a well-known killer feature of Emacs and supposedly the
greatest ~git~ interface ever invented.

Magit depends on ~git~ executable, make sure it's installed. On Windows, you can
download and install it from here https://git-scm.com/download/win

Also, git author must be properly configured. Either install ~.gitconfig~ from
this repository, or manually run the following commands. Works on Windows as
well.

#+BEGIN_SRC bash
git config --global user.email "frostyx@email.cz"
git config --global user.name "Jakub Kadlčík"
#+END_SRC

Finally, Install the ~magit~ package.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :if (executable-find "git")
  :ensure t)
#+END_SRC

The most basic key bindings are

| Key | Action                            | CLI alternative         |
|-----+-----------------------------------+-------------------------|
| s/S | stage a hunk, file or all files   | ~git add -p <file>~     |
| u/U | unstage a hunk, fiel or all files | ~git reset HEAD <file>~ |
| x   | discard                           | ~git checkout <file>~   |
| c   | commit                            | ~git commit~            |
| p/P | push                              | ~git push~              |

For more see https://github.com/emacs-evil/evil-magit#key-bindings

There is currently some upstream bug prioritizing normal Evil keys
over magit rebase keys. Which wouldn't be that awful but it affects
only normal mode. Insert mode uses the default rebase keys, and that
is super annoying.

See https://www.reddit.com/r/spacemacs/comments/q0eqcd/how_to_get_my_magit_keybindings_back_mode/

I am temporarily fixing the bug in my setup.

#+BEGIN_SRC emacs-lisp
(general-nmap
  :keymaps 'helm-ls-git-rebase-todo-mode-map
  "d" 'helm-ls-git-rebase-drop
  "e" 'helm-ls-git-rebase-edit
  "f" 'helm-ls-git-rebase-fixup
  "p" 'helm-ls-git-rebase-pick
  "r" 'helm-ls-git-rebase-reword
  "s" 'helm-ls-git-rebase-squash
  "x" 'helm-ls-git-rebase-exec
  "M-k" 'helm-ls-git-rebase-todo-move-up
  "M-j" 'helm-ls-git-rebase-todo-move-down)
#+END_SRC

Make sure magit doesn't override our hydra key binding

#+BEGIN_SRC emacs-lisp
(general-nmap
  :keymaps '(magit-status-mode-map magit-log-mode-map)
  "SPC" 'hydra-main/body)
#+END_SRC

** Git Forge

Communication over projects issues and pull requests consumes a big chunk of our
time as software developers. Let's make it more fun by not leaving Emacs and
doing it via Magit.

The configuration can be a little tricky so let's move in small steps that are
easier to debug. First, install the ~ghub~ package which provides API
implementation for various git forges such as GitHub, GitLab, etc.

See https://magit.vc/manual/ghub/

#+BEGIN_SRC emacs-lisp
(use-package ghub
  :ensure t
  :disabled t
  :quelpa (ghub :fetcher github
                :repo "FrostyX/ghub"
                :branch "pagure"))
#+END_SRC

To configure a GitHub account, you need to specify your username.

#+BEGIN_SRC bash
git config --global github.user frostyx
#+END_SRC

And then generate a token. I use the same one that I got for the official GitHub
client `gh`. It was stored in ~$HOME/.config/gh/hosts.yml~

See https://cli.github.com/manual/

We need to store the token into password manager, so that ~ghub~ can use it.

#+BEGIN_SRC bash
pass insert forge/api.github.com
#+END_SRC

To make sure that everything was configured properly and work as expected, try
running the following function.

#+BEGIN_SRC
(ghub-request "GET" "/user")
#+END_SRC

Now we can proceed to the ~forge~ installation, which is basically a Magit
interface for ~ghub~.

#+BEGIN_SRC emacs-lisp
(use-package forge
  :ensure t
  :disabled t
  :quelpa (forge :fetcher file
                 :path "/home/jkadlcik/git/forge/lisp"))
#+END_SRC

Improve the readability by adjusting colors and other visual elements.

#+BEGIN_SRC emacs-lisp
;; The forge package is currently disabled
;; (set-face-attribute 'forge-post-author nil :foreground my/blue)
;; (set-face-attribute 'forge-post-date nil :foreground my/yellow)
#+END_SRC

TODO table with commands


https://pagure.io/settings#nav-api-tab

#+BEGIN_SRC bash
git config --global pagure.user frostyx
#+END_SRC

#+BEGIN_SRC bash
pass insert forge/pagure.io
#+END_SRC

** File manager

There is already an awesome file manager built in Emacs, called ~dired~.

By default it doesn't automatically refresh opened directories, so any
changes from the outside (e.g. file operations done in the command-line)
doesn't apppear and user needs to manually refresh buffers using ~g~.
One of the problems is, that this key binding doesn't work with evil.

#+BEGIN_SRC emacs-lisp
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)
#+END_SRC

In Vim, I was used to open and close NerdTree with ~C-n~. Side-tree
file managers sux but let's keep the shortcut.

#+BEGIN_SRC emacs-lisp
(general-nmap "C-n" 'dired-jump)
#+END_SRC

You will probably find these Evil keybindings useful.

| Key binding | Explanation                  |
|-------------+------------------------------|
| RET         | Open a file or directory     |
| +           | Create a directory           |
| d           | Mark a file to be deleted    |
| x           | Delete marked files          |
| -           | Jump to the parent directory |
| C           | Copy a file or directory     |
| R           | Rename a file or directory   |


TODO Prevent ^ from jumping to the parent directory
TODO Bind backspace for accessing the parent directory
TODO Find useful hacks here https://github.com/Fuco1/dired-hacks

The standard ~ls~ output is a bit too much verbose for casual use. Let's hide
the details by default. To manually show/hide them,
use ~M-x dired-hide-details-mode~.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :hook (dired-mode . dired-hide-details-mode))
#+END_SRC

We can make Dired more beautiful and utilize the ~all-the-icons~ packge to
display filetype icons.

See https://github.com/jtbm37/all-the-icons-dired

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-dired
  :ensure t
  :hook
  (dired-mode . all-the-icons-dired-mode))
#+END_SRC

To use ~dired~ as a full-fledged file manager for all desktop environment usage,
we need to admit, that there exists a world outside of Emacs and that we need to
open some file types with dedicated applications.

https://github.com/Fuco1/dired-hacks#dired-open

#+BEGIN_SRC emacs-lisp
(use-package dired-open
  :ensure t)
#+END_SRC

Explicitly assign file types to the applications that should open them. I find
this more reliable than ~xdg-open~ which has been doing weird shit every time I
touched it in the last ten years.

#+BEGIN_SRC emacs-lisp
(setq dired-open-extensions
      '(("gif" . "eog")
        ("jpg" . "eog")
        ("png" . "eog")
        ("mkv" . "vlc --one-instance")
        ("mp4" . "vlc --one-instance")
        ("ogv" . "vlc --one-instance")
        ("avi" . "vlc --one-instance")
        ("odt"  . "libreoffice")
        ("docx" . "libreoffice")
        ("docx" . "libreoffice")))
#+END_SRC

Sometimes we would like to open a file in different application (e.g. editting
an image instead of viewing it, queueing a video instead of starting it
immediately, etc). For that, it is nice to have an "open with" dialog that is
commonly used in GUI file managers.

See https://github.com/FrostyX/helm-dired-open

#+BEGIN_SRC emacs-lisp
(use-package helm-dired-open
  :ensure t
  :quelpa (helm-dired-open
           :fetcher github
           :repo "FrostyX/helm-dired-open"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my/dired-vlc-enqueue ()
  (interactive)
  (let ((file (ignore-errors (dired-get-file-for-visit))))
	(dired-open--start-process file "vlc --one-instance --playlist-enqueue")))
#+END_SRC

To make the ~dired~ output more exciting, we can add some colors to it. There is
an out-of-the-box solution in the form of ~diredfl~ package but that colorizes
dired heavily and I feel like I would have to de-colorize it a little.

See https://github.com/purcell/diredfl

My choice is ~dired-rainbow~ which allows us to colorize files by their type or
permissions but we need to manually opt-in for each.

See https://github.com/Fuco1/dired-hacks#dired-rainbow

#+BEGIN_SRC emacs-lisp
(use-package dired-rainbow
  :ensure t)
#+END_SRC

This package is immensely annoying in one aspect. Instead of always redefining
the filetype <-> groups and groups <-> faces associations on each
~dired-rainbow-define~, it preserves the previous configuration. Therefore once
we define a group of filetypes and set a color for them, we cannot adjust it
with the same command. For this reason, I am creating the groups and simply set
their colors to ~nil~. And only later specify their faces.

#+BEGIN_SRC emacs-lisp
(dired-rainbow-define img nil ("gif" "jpg" "png"))
(dired-rainbow-define video nil ("mp4" "mkv" "ogv" "avi"))
(dired-rainbow-define office nil ("odt" "doc" "docx"))
(dired-rainbow-define pdf nil ("pdf"))
#+END_SRC

Now we can adjust the file type and permission colors.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'dired-rainbow-img-face nil :foreground my/green)
(set-face-attribute 'dired-rainbow-office-face nil :foreground my/yellow)
(set-face-attribute 'dired-rainbow-video-face nil :foreground my/orange)
(set-face-attribute 'dired-rainbow-pdf-face nil :foreground my/purple)
#+END_SRC

When using ~dired~ as an general purpose file manager, it is convenient to setup
bookmarks for non-project directories (e.g. movies and music folders).

| Command              | Explanation                                                  |
|----------------------+--------------------------------------------------------------|
| ~M-x bookmark-set~   | Create a bookmark                                            |
| ~M-x helm-bookmarks~ | List and jump to bookmarks                                   |
| ~M-x bookmark-save~  | Permanently save all bookmarks to ~$HOME/.emacs.d/bookmarks~ |

Highlight the whole cursor line when in ~dired~. I am blind as a bat and can't
easily read the whole filename by just having a cursor at the beginning of the line.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :hook (dired-mode . hl-line-mode))
#+END_SRC

By default ~dired~ uses space for moving the cursor to the next line, we want to
unbind that so that hydra works.

#+BEGIN_SRC emacs-lisp
(general-unbind 'normal dired-mode-map
  "SPC"
  "S-SPC")
#+END_SRC

It is well-known that Emacs can open archives (.tar, .zip, etc) but thanks to
~archive-rpm~, it can browse also SRPM and RPM packages. This is a game changer.

See https://github.com/legoscia/archive-rpm

#+BEGIN_SRC emacs-lisp
(use-package archive-rpm
  :ensure t)
#+END_SRC

One of the most killer features in GUI file managers is a menu for mounting
removable disks such as USB sticks and external drives. Let's do this in Emacs
as well.

See https://gitlab.com/tuedachu/udiskie.el

First, install the Fedora package that is internally used.

#+BEGIN_SRC emacs-lisp
(frostyx/dnf :install "udiskie")
#+END_SRC

And install the Emacs ~udiskie~ pacakge

#+BEGIN_SRC emacs-lisp
(use-package udiskie
  :if workstation-p
  :ensure t
  :disabled t
  :quelpa (udiskie
           :fetcher git
           :url "https://gitlab.com/tuedachu/udiskie.el.git"))
#+END_SRC

** Terminal

I am currently not using a terminal emulator inside of Emacs because all
available options handle terminal applications such as top, htop, docker, etc
very poorly. However, I would like to slowly collect my notes about terminal
emulators here, hoping that one day they will be usable for me.

See https://github.com/akermu/emacs-libvterm

Install the dependencies first

#+BEGIN_SRC emacs-lisp
(frostyx/dnf :install "libvterm")
#+END_SRC

Install ~vterm~ package.

#+BEGIN_SRC emacs-lisp
(use-package vterm
  :if workstation-p
  :ensure t)
#+END_SRC

Running ~M-x vterm~, spawns a terminal buffer, and all consequent calls of
~M-x vterm~ doesn't spawn a new terminal, but jumps to the previous one. Thanks
to ~multi-vterm~, we can have more of them.

See https://github.com/suonlight/multi-vterm

#+BEGIN_SRC emacs-lisp
(use-package multi-vterm
  :if workstation-p
  :ensure t)
#+END_SRC

For convenience, let's create a wrapper for spawning a named terminal. Unnamed
terminal buffers are a giant mess.

#+BEGIN_SRC emacs-lisp
(defun frostyx/multi-vterm-named ()
  (interactive)
  (multi-vterm)
  (multi-vterm-rename-buffer
   (read-string "Name: ")))
#+END_SRC

We need some easy way to jump back to prompt. Since it is at the bottom of the
buffer, I am choosing ~G~, but I think keys like ~I~, ~A~, ~i~, ~a~ should work
as well.

#+BEGIN_SRC emacs-lisp
(general-nmap
  :keymaps 'vterm-mode-map
  "G" #'vterm-reset-cursor-point)
#+END_SRC

** Tmux

Having terminal inside of Emacs is sick AF but I won't be running
anything outside of Tmux anymore. We want persistent terminals!

There is a library for Emacs -> Tmux communication
See https://github.com/emacsorphanage/emamux

#+BEGIN_SRC emacs-lisp
(use-package emamux
  :load-path "/home/jkadlcik/git/emamux"
  :ensure t)
#+END_SRC

My goal is to implement helm-centric interface for Tmux. The following
code is still work in progress.

Access Tmux even in normal mode using ~C-b~

#+BEGIN_SRC emacs-lisp
(general-nmap
  :keymaps 'vterm-mode-map
  "C-b" (lambda ()
          (interactive)
          (evil-collection-vterm-insert)
          (vterm-send-key "b" nil nil t)))
#+END_SRC

List all Tmux sessions

#+BEGIN_SRC emacs-lisp
(defun frostyx/tmux-sessions ()
  (interactive)
  (let* ((choices (emamux:get-sessions)))
	(completing-read "Sessions: " choices)))
#+END_SRC

List all windows inside of a specific Tmux session

#+BEGIN_SRC emacs-lisp
(defun frostyx/tmux-windows ()
  (interactive)
  (let* ((emamux:session "51")
		 (choices (emamux:list-windows)))
	(completing-read "Window: " choices)))
#+END_SRC

Rename window

#+BEGIN_SRC emacs-lisp
(defun frostyx/tmux-rename-window ()
  (interactive)
  (let* ((emamux:session "2")
		 (window (emamux:get-window))
		 (name (read-string "Name: ")))
	(emamux:tmux-run-command t "rename-window" name)))
#+END_SRC

Rename session

#+BEGIN_SRC emacs-lisp
(defun frostyx/tmux-rename-session ()
  (interactive)
  (let* ((emamux:session "2")
		 (name (read-string "Name: ")))
	(emamux:tmux-run-command t "rename-session" "-t" emamux:session name)))
#+END_SRC

Hide status bar

#+BEGIN_SRC emacs-lisp
(defun frostyx/hide-status-bar ()
  (interactive)
  (let* ((emamux:session "9"))
	(emamux:tmux-run-command t "set" "-t" emamux:session "status" "off")))
#+END_SRC

TODO

- Modeline indicator that we are in tmux (Tmux: Session -> Window)

- Figuring out tmux session for the current emacs window
    - https://github.com/akermu/emacs-libvterm/issues/482
      echo $TMUX
	  tmux display-message -p '#S'
	  tmux display-message -p '#W'

	- Spawn and keep opened a new vterm named ~*tmux-observer*~ and run commands
      in it. AFAIK if command starts with a space it doesn't go to bash history

	  tmux list-clients -F "#{client_pid} #{session_name} #{window_name}"
      (alist-get 'ppid (process-attributes 263378))

- Actions for our ~completing-read~ commands
- ~A~, ~G~, ~I~, etc shouild go to prompt

** Web
*** EWW
EWW notes here
Key bindings
https://github.com/emacs-evil/evil-collection/blob/master/modes/eww/evil-collection-eww.el
o - open
go - open in external browser

*** w3m

First we need to install the ~w3m~ dependency.

#+BEGIN_SRC emacs-lisp
(frostyx/dnf :install "w3m")
#+END_SRC

Now we can install the Emacs w3m interface.

#+BEGIN_SRC emacs-lisp
(use-package w3m
  :if workstation-p
  :ensure t
  :config
  nil)
#+END_SRC

** Email

Here is a great tutorial for setting up ~mbsync~, ~mu~, and ~mu4e~.
https://www.youtube.com/watch?v=newRHXKm4H4
Unfortunatelly it is only for one email account.

The prerequisite for this setup is having the following packages installed.

#+BEGIN_SRC emacs-lisp
(frostyx/dnf :install "isync maildir-utils")
#+END_SRC

A ~mu~ index needs to be initialized with an email address.

See https://emacs.stackexchange.com/a/59485

#+BEGIN_SRC bash
mu init --maildir=~/Mail \
        --my-address=frostyx@email.cz \
        --my-address=jakub.kadlcik@gmail.com \
        --my-address=jkadlcik@redhat.com
mu index
#+END_SRC

The ~mu4e~ package is not available on MELPA, let's load it from system.

#+BEGIN_SRC emacs-lisp
(use-package mu4e
  :if workstation-p
  :ensure nil
  :load-path "/usr/share/emacs/site-lisp/mu4e"
  :init
  ;; New versions of mu4e use Gnus-based email viewer that has more features than the
  ;; old one (namely images support, calendar support, etc). However, it sometimes
  ;; lags the whole Emacs and needs to be killed. Let's continue using the old viewer
  ;; for a little longer and see if the situation improves in the future.
  ;; ...
  ;; Trying the new view now
  (setq mu4e-view-use-old nil)

  :config

  ;; https://etienne.depar.is/emacs.d/mu4e.html
  (setq mu4e-split-view nil)
  (setq mu4e-headers-visible-columns 67)
  (setq mu4e-html2text-command "w3m -dump -T text/html -cols 72 -o display_link_number=true -o auto_image=false -o display_image=false -o ignore_null_img_alt=true")
  (setq mu4e-view-show-addresses t)
  (setq message-kill-buffer-on-exit t)
  (setq mu4e-update-interval 300) ;; five minutes
  (setq mail-user-agent 'message-user-agent)
  (setq mail-specify-envelope-from t)
  (setq auth-source-debug t)
  (setq auth-source-do-cache nil)


  ;; Sync everything by `mbsync -a`
  (setq mu4e-get-mail-command "mbsync seznam gmail redhat")

  ;; @TODO notifications
  ;; https://github.com/iqbalansari/mu4e-alert

  ;; Havent tested it yet, but it looks like a great feature
  ;; https://www.reddit.com/r/emacs/comments/fu8ln7/in_mu4e_1310_how_do_i_open_an_email_in_browser/fmbbfz2?utm_source=share&utm_medium=web2x
  (add-to-list 'mu4e-view-actions
    '("View in Browser" . mu4e-action-view-in-browser) t))
#+END_SRC

Fix the awful font in the message view. Using the default font here but
duplicating its definition. There should probably be a better way to do
it. Also, please note that the face is not mu4e-specific and therefore it may
affect other packages.

#+BEGIN_SRC emacs-lisp
(set-face-attribute
  'variable-pitch nil
  :family "vera sans"
  :height 90
  :weight 'normal
  :width 'normal
  :slant 'normal)
#+END_SRC

Mu4e sometimes stucks, locks the whole mail cache and doesn't update
anymore. And refuses to update even from the outside via ~mu index~ because of
the existing lock. This helps and unfortunatelly, I need to run it several times
every day.

#+BEGIN_SRC emacs-lisp
(defun frostyx/unfuck-mu4e ()
  (interactive)
  (kill-process " *mu4e-proc*"))
#+END_SRC

** Mu4e Helm support

This collection of code-snippets should ideally be distribute as a new package
called e.g. ~mu4e-helm~ and provide out-of-the-box helm completion for Mu4e.

Jump to a maildir using helm

See https://emacs.stackexchange.com/questions/47535/setup-helm-for-mu4e-jump-to-maildir

#+BEGIN_SRC emacs-lisp
(defun my/mu4e-jump-maildir ()
  (interactive)
  (let ((maildir (helm-comp-read "Maildir: " (mu4e-get-maildirs))))
    (mu4e-headers-search (format "maildir:\"%s\"" maildir))))

(evil-define-key 'normal mu4e-main-mode-map (kbd "J") 'my/mu4e-jump-maildir)
(evil-define-key 'normal mu4e-headers-mode-map (kbd "J") 'my/mu4e-jump-maildir)
(evil-define-key 'normal mu4e-view-mode-map (kbd "J") 'my/mu4e-jump-maildir)
#+END_SRC

*** Listing emails

Do not show threads, they are unnecessarily confusinig. They can easily be
toggled on and off by ~z t~, and it is really easy to narrow the search to only
one thread by ~a s~ when reading a message.

Ideally I would prefer something like Gmail threads concept, we might
investigate it in the future.

#+BEGIN_SRC emacs-lisp
(setq mu4e-headers-show-threads nil)
#+END_SRC

We want to wrap long lines, so the message reading is more comfortable.
See the ".3.3 How can I word-wrap long lines in when viewing a message?" section
on https://www.djcbsoftware.nl/code/mu/mu4e/Reading-messages.html

#+BEGIN_SRC emacs-lisp
(add-hook 'mu4e-view-mode-hook 'visual-line-mode)
#+END_SRC

By default, ~mu4e~ has mapped a scrolling function to the space button, I want
my hydra instead.

#+BEGIN_SRC emacs-lisp
(evil-define-key 'normal mu4e-view-mode-map (kbd "SPC") nil)
(evil-define-key 'normal mu4e-headers-mode-map (kbd "SPC") nil)
#+END_SRC

We want to colorize some of the columns, so the email view is better readable
and more importantly more sexy. The support for this isn't built into mu4e and
requires an additional package.

See https://github.com/Alexander-Miller/mu4e-column-faces

#+BEGIN_SRC emacs-lisp
(use-package mu4e-column-faces
  :if workstation-p
  :ensure t
  :after mu4e
  :config
  (mu4e-column-faces-mode))
#+END_SRC

Customize the ~from~ column color:

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'mu4e-column-faces-to-from nil
                    :foreground my/blue)
#+END_SRC

Don't highlight unread emails with bold text, we have colors for that.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'mu4e-unread-face nil
                    :weight 'normal)
#+END_SRC

Customize the font of currently highlighted line

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'mu4e-header-highlight-face nil
                    :weight 'normal
                    :underline nil)
#+END_SRC

Mu4e offers a possiblity to use symbols instead of letters, however it doesn't
really work. The output of messages list is weirdly aligned.

See https://github.com/djcb/mu/issues/1062

For the time being, let's go with non-fancy characters. But a possible solution
would be to add a space after some special characters, see the linked issue.

#+BEGIN_SRC emacs-lisp
(setq mu4e-use-fancy-chars t)
(setq mu4e-headers-unread-mark '("u" . "u")
      mu4e-headers-draft-mark '("D" . "D")
      mu4e-headers-seen-mark '("S" . "S")
      mu4e-headers-unseen-mark '("u" . "u")
      mu4e-headers-flagged-mark '("F" . "F")
      mu4e-headers-new-mark '("N" . "N")
      mu4e-headers-replied-mark '("R" . "R")
      mu4e-headers-passed-mark '("P" . "P")
      mu4e-headers-encrypted-mark '("x" . "x")
      mu4e-headers-signed-mark '("s" . "s")
      mu4e-headers-trashed-mark '("T" . "T")
      mu4e-headers-attach-mark '("a" . "a"))
#+END_SRC

Let's customize the columns that should be showed in the messages list. Each
column should be set as a pair of a field and its width (it can be ~nil~, in
that case the column width is going to be unlimited. Better to only use that for
the last column)

#+BEGIN_SRC emacs-lisp
(setq mu4e-headers-fields
      '((:from . 20)
        (:thread-subject . nil)))
#+END_SRC

Ideally we would like to have a multiple headers views, one slim, designed for
80 column window, other full-sized.

#+BEGIN_SRC emacs-lisp
(setq my/mu4e-headers-fields-full
      '((:human-date . 20)
        (:flags . 10)
        (:from . 30)
        (:thread-subject . nil)))
#+END_SRC

We set a human-readable date/time format in the messages list view, so we should
rather a one, that is really readable for us (i.e. not the American one).

#+BEGIN_SRC emacs-lisp
(setq mu4e-headers-date-format "%d. %m. %Y")
(setq mu4e-headers-time-format "%H:%M")
#+END_SRC

Show only the results that would command-line ~mu find~ return, nothing else.

#+BEGIN_SRC emacs-lisp
(setq mu4e-headers-include-related nil)
#+END_SRC

We would like to have some inteligent threading and Gmail-like conversation view.

#+BEGIN_SRC emacs-lisp
(use-package mu4e-thread-folding
  :if workstation-p
  :quelpa (mu4e-thread-folding
           :fetcher github
           :repo "rougier/mu4e-thread-folding"))
#+END_SRC

The configuration is still WIP.

#+BEGIN_SRC emacs-lisp
(if (featurep 'mu4e-thread-folding)
    (progn
      (set-face-attribute 'mu4e-thread-folding-root-unfolded-face nil :background my/gray)
      (set-face-attribute 'mu4e-thread-folding-child-face nil :background my/black)

      (add-to-list 'mu4e-header-info-custom
                   '(:empty . (:name "Empty"
                                     :shortname ""
                                     :function (lambda (msg) "  "))))

      (setq mu4e-headers-fields
            '((:empty . 0)
              (:from . 20)
              (:subject . 65)))))

;; (setq mu4e-headers-thread-child-prefix '("|" . "| "))
;; (setq mu4e-headers-thread-connection-prefix '("|" . "| "))
;; (setq mu4e-headers-thread-last-child-prefix '("|" . "| "))
;; (setq mu4e-headers-thread-single-orphan-prefix '("|" . "| "))
;; (setq mu4e-headers-thread-orphan-prefix '("|" . "| "))
#+END_SRC

*** Sending emails

The ~mu4e~ system package provides also a library for sending emails.

See https://www.djcbsoftware.nl/code/mu/mu4e/Sending-mail.html

#+BEGIN_SRC emacs-lisp
(use-package smtpmail
  :if workstation-p
  :ensure t
  :load-path "/usr/share/emacs/site-lisp/mu4e")
#+END_SRC

And now some black magic configuration, see

https://www.emacswiki.org/emacs/SendingMail

#+BEGIN_SRC emacs-lisp
(setq message-send-mail-function 'smtpmail-send-it
      starttls-use-gnutls t
      smtpmail-debug-info t)
#+END_SRC

*** Reading emails

Don't try to colorize text in html emails. Sometimes it is nice and
pretty but very often it just shows black text on black background.

#+BEGIN_SRC emacs-lisp
(setq shr-use-colors nil)
#+END_SRC

*** Email queries

We don't always want to dig through the entire mailbox but rather see a filtered
mail, e.g. last weeks mail for a specific email address. Mu4e bookmarks are the
thing.

See https://www.djcbsoftware.nl/code/mu/mu4e/Bookmarks.html

#+BEGIN_SRC emacs-lisp
(custom-reevaluate-setting 'mu4e-bookmarks)

(add-to-list 'mu4e-bookmarks
  '(:name "Red Hat shortcut"
    :query "date:1w.. and maildir:/redhat/INBOX/"
    :key ?r))

(add-to-list 'mu4e-bookmarks
  '(:name "Gmail shortcut"
    :query "date:1w.. and maildir:/gmail/INBOX/"
    :key ?g))

(add-to-list 'mu4e-bookmarks
  '(:name "Seznam shortcut"
    :query "date:1w.. and maildir:/seznam/INBOX/"
    :key ?s))
#+END_SRC

*** Email accounts

Everyone has at least two email accounts and who sais he doesn't, he is
lying. In Mu4e, accounts are managed through "contexts". For an example contexts
configuration, please see

https://emacs.stackexchange.com/a/50365

First, let's configure my personal email for online stuff.

#+BEGIN_SRC emacs-lisp
(if workstation-p
    (setq my/mu4e-seznam-context
          (make-mu4e-context
           :name "seznam"
           :enter-func (lambda () (mu4e-message "Entering seznam context"))
           :leave-func (lambda () (mu4e-message "Leaving seznam context"))
           :match-func (lambda (msg)
		                 (when msg
		                   (mu4e-message-contact-field-matches
			                msg '(:from :to :cc :bcc) "frostyx@email.cz")))
           :vars '((user-mail-address . "frostyx@email.cz")
                   (user-full-name . "Jakub Kadlčík")
                   (smtpmail-smtp-user . "frostyx@email.cz")
                   (smtpmail-default-smtp-server . "smtp.seznam.cz")
                   (smtpmail-smtp-server . "smtp.seznam.cz")
                   (smtpmail-smtp-service . 587)
                   (mu4e-sent-messages-behavior . sent)))))
#+END_SRC

Now, my personal Gmail account for IRL stuff.

#+BEGIN_SRC emacs-lisp
(if workstation-p
    (setq my/mu4e-gmail-context
          (make-mu4e-context
           :name "gmail"
           :enter-func (lambda () (mu4e-message "Entering gmail context"))
           :leave-func (lambda () (mu4e-message "Leaving gmail context"))
           :match-func (lambda (msg)
		                 (when msg
		                   (mu4e-message-contact-field-matches
			                msg '(:from :to :cc :bcc) "jakub.kadlcik@gmail.com")))
           :vars '((user-mail-address . "jakub.kadlcik@gmail.com")
	               (user-full-name . "Jakub Kadlčík")
	               (smtpmail-smtp-user . "jakub.kadlcik")
	               (smtpmail-default-smtp-server . "smtp.gmail.com")
	               (smtpmail-smtp-server . "smtp.gmail.com")
	               (smtpmail-smtp-service . 587)
	               (mu4e-sent-messages-behavior . delete)))))
#+END_SRC

And lastly, my work email account.

#+BEGIN_SRC emacs-lisp
(if workstation-p
    (setq my/mu4e-redhat-context
          (make-mu4e-context
           :name "redhat"
           :enter-func (lambda () (mu4e-message "Entering redhat context"))
           :leave-func (lambda () (mu4e-message "Leaving redhat context"))
           :match-func (lambda (msg)
		                 (when msg
		                   (mu4e-message-contact-field-matches
			                msg '(:from :to :cc :bcc) "jkadlcik@redhat.com")))
           :vars '((user-mail-address . "jkadlcik@redhat.com")
	               (user-full-name . "Jakub Kadlčík")
	               (smtpmail-smtp-user . "jkadlcik@redhat.com")
	               (smtpmail-default-smtp-server . "smtp.gmail.com")
	               (smtpmail-smtp-server . "smtp.gmail.com")
	               (smtpmail-smtp-service . 587)
	               (mu4e-sent-messages-behavior . delete)))))
#+END_SRC

So far, we only created those context configurations. They need to be passed to mu4e.

#+BEGIN_SRC emacs-lisp
(if workstation-p
    (setq mu4e-contexts (list my/mu4e-seznam-context
			                  my/mu4e-gmail-context
			                  my/mu4e-redhat-context)))
#+END_SRC

Authentication for receiving emails is managed elsewhere but for sending emails,
we need to configure it here. Let's store passwords in the ~pass~ utility (obviously).

#+BEGIN_SRC emacs-lisp
(setq auth-sources '(password-store))
#+END_SRC

Try to send an email and see if it fails. If yes, check ~*Messages*~ buffer for
a bunch of lines like this. Hint, don't launch ~mu4e~ for testing this, use ~C-x
m~ shortcut.

#+BEGIN_SRC
auth-source-pass: found no entries matching "frostyx@email.cz@smtp.seznam.cz"
auth-source-pass: found no entries matching "smtp.seznam.cz:587/frostyx@email.cz"
auth-source-pass: found no entries matching "smtp.seznam.cz/frostyx@email.cz"
#+END_SRC

Pick whichever is the most suitable format to you and add a password for it into
your ~pass~ database. Personally, I did

#+BEGIN_SRC bash
pass insert email/frostyx@email.cz@seznam.cz
pass insert email/jakub.kadlcik@gmail.com
pass insert email/jkadlcik@redhat.com@gmail.com
#+END_SRC

*** Mu4e dashboard

Mu4e dashboard allows to write an Org mode document containing links to ~mu~
queries and therefore provide a nice navigation and mails count. It is currently
the best way to implement the standard email client side bar.

See https://github.com/rougier/mu4e-dashboard

#+BEGIN_SRC emacs-lisp
(use-package mu4e-dashboard
  :if workstation-p
  :quelpa (mu4e-dashboard
           :fetcher github
           :repo "rougier/mu4e-dashboard"))
#+END_SRC

My dashboard is defined in ~./mu4e-dashboard.org~ but I cannot publish it yet
since it contains sensitive personal information. Once I figure out how to alias
those queries, I will publish it.

The usage is not that straightforward. First, open the document, then run ~M-x
mu4e-dashboard-mode~ to make it read-only and actionable. Then run ~M-x
org-toggle-link-display~ to hide full links if needed. It would be also nice to
hide/render the rest of the Org mode syntax. Once I finish this, I will create a
simple launcher and possibly submit a PR for it.

** RSS

Probably the best available RSS client for Emacs is elfeed. It allows
asynchronious sync, automatical refresh by using internal timers, and more.
It provides a user-interface decoupled from the backend logic so we have an
opportunity to implement our own views.

#+BEGIN_SRC emacs-lisp
(use-package elfeed
  :if workstation-p
  :ensure t
  :commands (elfeed)
  :config
  (setq-default elfeed-search-filter ""))
#+END_SRC

Managing our RSS feeds in org file is much more cool than having them in
a list of lists.

#+BEGIN_SRC emacs-lisp
(use-package elfeed-org
  :if workstation-p
  :ensure t
  :config
  (elfeed-org))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq rmh-elfeed-org-files (list "~/.emacs.d/elfeed.org"))
#+END_SRC

We have so many feeds subscribed and not enough time to read them
all. By default show only the work-related articles.

#+BEGIN_SRC emacs-lisp
(setq elfeed-search-filter "+work")
#+END_SRC

Automatically fetch updates from RSS feeds. Let's do it every day, but I am
afraid, that it will lag the whole Emacs, so we will probably need to adjust it
and run less frequently.

See:
- https://github.com/skeeto/elfeed/issues/304
- https://www.reddit.com/r/emacs/comments/bvbp92/is_there_a_simple_way_to_get_elfeed_to_update/

#+BEGIN_SRC emacs-lisp
(setq my/elfeed-update-timer
  (run-at-time nil (* 1 60 60 24) #'elfeed-update))
#+END_SRC

Use ~M-x helm-timers~ to see (and cancel) executed timers.

Very likely we will need to execute operation accross every displayed article

See https://emacs.stackexchange.com/a/2441

#+BEGIN_SRC emacs-lisp
(defun elfeed-apply-for-all (f)
  (interactive)
  (mark-whole-buffer)
  (f))
#+END_SRC

Such as marking everything as read

#+BEGIN_SRC emacs-lisp
(defun elfeed-mark-all-as-read ()
  (elfeed-apply-for-all elfeed-search-untag-all-unread))
#+END_SRC

You will probably find these keybindings useful.

| Key binding | Explanation                   |
|-------------+-------------------------------|
| RET         | Open article in elfeed        |
| o           | Open article in a web browser |
| r           | Fetch new articles            |
| u           | Mark article as read          |
| U           | Mark article as unread        |
| +           | Add tag                       |
| -           | Remove tag                    |
| S           | Stop all fetching processes   |

Define custom key bindings for the list of articles

#+BEGIN_SRC emacs-lisp
(with-eval-after-load "elfeed-search"
  (evil-define-key*
    'normal elfeed-search-mode-map
    "RET" #'elfeed-search-show-entry
    "o" #'elfeed-search-browse-url
    "r" #'elfeed-search-fetch
    "S" #'elfeed-unjam))
#+END_SRC

Define custom key bindings for when reading an article

#+BEGIN_SRC emacs-lisp
(with-eval-after-load "elfeed-show"
  (evil-define-key*
    'motion elfeed-show-mode-map
    "gb" #'elfeed-show-visit
    "gj" #'elfeed-show-next
    "gk" #'elfeed-show-prev))
#+END_SRC

Finally, customize colors

#+BEGIN_SRC emacs-lisp
(set-face-attribute
 'elfeed-search-date-face nil
 :foreground my/blue)

(set-face-attribute
 'elfeed-search-title-face nil
 :foreground nil)

(set-face-attribute
 'elfeed-search-feed-face nil
 :foreground my/blue)

(set-face-attribute
 'elfeed-search-tag-face nil
 :foreground my/green)

(set-face-attribute
 'elfeed-search-unread-title-face nil
 :foreground my/purple
 :weight 'normal
 :width 'normal)
#+END_SRC

Don't show any date, we don't have enough space for that

#+BEGIN_SRC emacs-lisp
(defun elfeed-search-format-date (date)
  "")
#+END_SRC

We also need a less space for article authors in favor of their
titles.

#+BEGIN_SRC emacs-lisp
(setq elfeed-search-trailing-width 15)
#+END_SRC

** IRC

There are several Emacs IRC clients available (such as ERC, rcirc and others)
but Circe is the one trying to be modern and be pretty out of the box.

See https://github.com/jorgenschaefer/circe

Temporarily we want to install Circe from a patched source
https://github.com/jorgenschaefer/circe/pull/384

#+BEGIN_SRC emacs-lisp
(use-package circe
  :if workstation-p
  :ensure t
  :quelpa (circe :fetcher github
                 :repo "FrostyX/circe"
                 :branch "circe-tracking-colors"))
#+END_SRC

Do not forget to kill circe and run it again after modifying
~circe-network-options~ variable.

*** Network & channels

#+BEGIN_SRC emacs-lisp
(setq circe-network-options
      `(("Freenode"
         :tls t
         :nick "FrostyX"
         :sasl-username "FrostyX"
         :sasl-password ,(password-store-get "irc/freenode-password")
         :nickserv-nick "FrostyX"
         :nickserv-password ,(password-store-get "irc/freenode-password")
         :channels ("#fedora-admin"
                    "#fedora-buildsys"
                    "#tito"
                    "#emacs-circe"))

        ("Libera"
         :host "irc.libera.chat"
         :port 6697
         :tls t
         :nick "FrostyX"
         :sasl-username "FrostyX"
         :sasl-password ,(password-store-get "irc/libera-password")
         :nickserv-nick "FrostyX"
         :nickserv-password ,(password-store-get "irc/libera-password")
         :channels ("#fedora-admin"
                    "#fedora-buildsys"
                    "#tito"
                    "#emacs"
                    "#emacs-circe"))

        ("OFTC"
         :tls t
         :nick "FrostyX"
         :channels ("#qtile"))

        ("RedHat"
         :host ,(password-store-get "irc/redhat-host")
         :port 6667
         :tls nil
         :nick "jkadlcik"
         :channels ("#brno" "#copr"))

        ("Gnome"
         :host "irc.gnome.org"
         :port 6667
         :tls nil
         :nick "FrostyX"
         :channels ("#nautilus"))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my/circe ()
  (interactive)
  (circe "Libera")
  (circe "OFTC")
  (circe "RedHat"))
#+END_SRC

*** General configuration

Make sure that we see lags and automatically reconnects if we got disconnected.

#+BEGIN_SRC emacs-lisp
(circe-lagmon-mode)
#+END_SRC

By default, circe only tries to reconnect back to server a given number of times
and then gives up. We want to keep trying indefinitely even though it is not
recommended.

#+BEGIN_SRC emacs-lisp
(setq circe-server-max-reconnect-attempts nil)
#+END_SRC

Let us know that it is a new day so we can go to bed already.

FIXME I needed to disable it oterwise it messes with tracking

#+BEGIN_SRC emacs-lisp
;; (enable-circe-new-day-notifier)
#+END_SRC

Living without TAB completion for nicknames is out of the question.

#+BEGIN_SRC emacs-lisp
(setq circe-use-cycle-completion t)
#+END_SRC

But we definitelly don't want to use helm for it.

See https://github.com/jorgenschaefer/circe/wiki/Configuration#tab-completion

#+BEGIN_SRC emacs-lisp
(setq my/circe-major-modes
      '(circe-channel-mode
        circe-query-mode
        circe-server-mode))
(setq helm-mode-no-completion-in-region-in-modes my/circe-major-modes)
#+END_SRC

Don't put server name into the buffer name

#+BEGIN_SRC emacs-lisp
(setq circe-chat-buffer-name "{target}")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my/circe-autoscroll ()
  (setq scroll-down-aggressively 0.5))
(add-hook 'lui-mode-hook 'my/circe-autoscroll)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq lui-time-stamp-only-when-changed-p nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq circe-reduce-lurker-spam t)
#+END_SRC

TODO If you want to quit IRC ... insert funny joke from wiki use
     ~M-x kill-buffer~ and select the freenode server buffer.

Chat history is important. Enable logging.

#+BEGIN_SRC emacs-lisp
(setq lui-logging-directory "~/.emacs.d/circe")
(load "lui-logging" nil t)
(enable-lui-logging-globally)
#+END_SRC

*** Circe Modeline

See the newest buffer activity fist. But also, prioritize notifications over
just normal messages in a channel.

#+BEGIN_SRC emacs-lisp
(setq tracking-most-recent-first t)
(setq tracking-sort-faces-first t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq tracking-shorten-buffer-names-p nil)
#+END_SRC

I would prefer to set maximum with of the segment (probably in percentages in
ratio to the current width of the bar/window) but that doesn't seem to be
supported and I don't want to implement the feature right now, so let's just set
the maximum number of displayed buffers in the tracking segment. If we don't do
so, the output might get too lengthy and not be displayed at all. This still
might happen, when the channel names are too long but it's better than nothing.

#+BEGIN_SRC emacs-lisp
(setq tracking-max-mode-line-entries 3)
#+END_SRC

Define a custom spaceline segment for showing a list of channels with activity.
See https://github.com/TheBB/spaceline/issues/39#issuecomment-218469366

TODO we want better colors here, highlight needs to be red

#+BEGIN_SRC emacs-lisp
(spaceline-define-segment circe-track
  (when (and tracking-buffers
             (member major-mode my/circe-major-modes))
    (tracking-status))
  :priority 99)
#+END_SRC

Define a custom spaceline segment for showing the current IRC network lag.

TODO When lag <= 0.1, show "online" in green color

#+BEGIN_SRC emacs-lisp
(spaceline-define-segment circe-lagmon
  (when (and circe-lagmon-mode
             (member major-mode my/circe-major-modes))
    (circe-lagmon-format-mode-line-entry))
  :face other-face
  :priority 99)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(spaceline-toggle-circe-track-on)
(spaceline-toggle-circe-lagmon-on)
(spaceline-spacemacs-theme 'circe-lagmon 'circe-track)
(spaceline-compile)
#+END_SRC

Customize modeline colors for channels and personal messages

#+BEGIN_SRC emacs-lisp
(if workstation-p
	(progn
	  (setq tracking-get-face-function #'circe-tracking-get-face)
	  (set-face-attribute 'circe-tracking-channel-face nil :foreground my/white)
	  (set-face-attribute 'circe-tracking-query-face nil :foreground my/blue)))
#+END_SRC

*** Circe Notifications

By default, circe doesn't support notifications. Luckily it is a matter of
installing one additional package.

See https://github.com/eqyiel/circe-notifications

#+BEGIN_SRC emacs-lisp
(use-package circe-notifications
  :if workstation-p
  :ensure t
  :config
  (enable-circe-notifications))
#+END_SRC

By default, typical ~libnotify~ notifications are sent. You can emulate them by
~/usr/bin/notify-send~ command. This is not what I like.
My notification style of choice is setting window urgency. Window managers
typically know that there is an urgent window on some workspace/group and
highlight them in the panel.

See https://github.com/jwiegley/alert#builtin-alert-styles

#+BEGIN_SRC emacs-lisp
(setq circe-notifications-alert-style 'x11)
#+END_SRC

It doesn't matter when I was notified from some user the last time. Notify me
again. It's not spam.

#+BEGIN_SRC emacs-lisp
(setq circe-notifications-wait-for 0)
#+END_SRC

*** Messages format

#+BEGIN_SRC emacs-lisp
(setq circe-format-say "<{nick}>  {body}")
#+END_SRC

See https://github.com/jorgenschaefer/circe/wiki/Configuration#inline-nick-reply

#+BEGIN_SRC emacs-lisp
(setq circe-format-self-say "<{nick}>  {body}")
#+END_SRC

Finally, let's configure circe colors.

My nick highlighted in the chat but more importantly color of a buffer where
I was mentioned, in the circe-tracking modeline segment

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'circe-highlight-nick-face nil :foreground my/red)
#+END_SRC

Hard wrap at 70 characters. This is a limit specifically for the message
body. With timestamp prefix, the columns are basically 80 characters long.

#+BEGIN_SRC emacs-lisp
(setq lui-fill-column 70)
#+END_SRC

Ideally we would like to indent the message to the
exact column that it started but it is not that easy. So until then, indent new
lines of a message with a typical 4 spaces.

#+BEGIN_SRC emacs-lisp
(setq lui-fill-type "    ")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq lui-time-stamp-position 'left)
(setq lui-time-stamp-format "[%H:%M]  ")
#+END_SRC

*** Prompt

See https://github.com/jorgenschaefer/circe/wiki/Configuration#channel-name-in-the-prompt

#+BEGIN_SRC emacs-lisp
(add-hook 'circe-chat-mode-hook 'my-circe-prompt)
(defun my-circe-prompt ()
  (lui-set-prompt
   (concat "[" (propertize (buffer-name) 'face 'circe-prompt-face) "]  ")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(enable-circe-color-nicks)
#+END_SRC

Sometimes it is usefull to just navigate with arrow keys in prompt to repeat
previous messages. By default, this feature is bound to ~M-p~ and ~M-n~ but it
coildes with my Window Manager key bindings, so let's just use arrow keys. I use
~hjkl~ for movement anyway.

#+BEGIN_SRC emacs-lisp
(define-key circe-channel-mode-map (kbd "<up>") 'lui-previous-input)
(define-key circe-channel-mode-map (kbd "<down>") 'lui-next-input)
#+END_SRC

*** Helm support for Circe

See https://emacs.stackexchange.com/a/37515

TODO Use https://github.com/lesharris/helm-circe instead

#+BEGIN_SRC emacs-lisp
(setq my/circe-buffers-source
  (helm-make-source "Circe Buffers" 'helm-source-buffers
    :buffer-list
    (lambda ()
      (mapcar #'buffer-name
              (cl-remove-if-not
               (lambda (buf)
                 (with-current-buffer buf
                   (derived-mode-p 'lui-mode)))
               (buffer-list))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my/circe-switch-to-buffer ()
  (interactive)
  (let ((helm-source-buffers-list my/circe-buffers-source))
    (helm-buffers-list)))
#+END_SRC

*** Circe TODO

TODO my messages format
TODO time stamp gray color and remove brackts
TODO Day changed message like in weechat
TODO logging file format like weechat has, see ~lui-logging-file-format~
TODO change message format (date should go before nick)

TODO ignore non-user messages in tracklist
TODO read message from tracklist when switching window (not only when switching buffer)

** Matrix

See https://matrix.org/
If confused, use web client https://app.element.io

In Emacs, we are going to use Ement.el
See https://github.com/alphapapa/ement.el

We need to install ~plz~ dependency first.

#+BEGIN_SRC emacs-lisp
(use-package plz
  :quelpa (plz :fetcher github
               :repo "alphapapa/plz.el"))
#+END_SRC

Now the actual ement client.

#+BEGIN_SRC emacs-lisp
(use-package ement
  :quelpa (ement :fetcher github
                 :repo "alphapapa/ement.el"))
#+END_SRC

I have two accounts, ~@frostyx:fedora.im~ and
~@frostyx:matrix.org~. So far I have now idea if I need them both or
not, if I can connect from Fedora account to matrix.org rooms and how
to connect to the Fedora account from ement.

Use ~M-x ement-connect~ to open the client.

*** Matrix rooms

Don't display room icons in the top line

#+BEGIN_SRC emacs-lisp
(setq ement-room-avatars nil)
#+END_SRC

Don't put any prefixes and suffixes into room names. They have
specific major modes anyway, so we know what those buffers are.

#+BEGIN_SRC emacs-lisp
(setq ement-room-buffer-name-prefix "")
(setq ement-room-buffer-name-suffix "")
#+END_SRC

I am trying to imitate 15 years of my IRC user experience, that
started with Irssi, hence no margins and both timestamp and nick on
the left.

#+BEGIN_SRC emacs-lisp
(setq ement-room-right-margin-width 0)
(setq ement-room-left-margin-width 0)
(setq ement-room-message-format-spec "[%t] <%S>  %B%r")
#+END_SRC

Save a little bit of space by not showing seconds in timestamps

#+BEGIN_SRC emacs-lisp
(setq ement-room-timestamp-format "%H:%M")
#+END_SRC

Customize timestamp face to have the same color as in Circe. It seems
that the color is not in our base16 theme, so we should change it.

#+BEGIN_SRC emacs-lisp
(set-face-attribute
 'ement-room-timestamp nil
 :foreground "#12cfc0")
#+END_SRC

There is a horizontal separating the unread messages in the
buffer. Ideally, I would like to disable it but I can live with it
having a gray color.

#+BEGIN_SRC emacs-lisp
(set-face-attribute
 'ement-room-fully-read-marker nil
 :foreground my/gray)

(set-face-attribute
 'ement-room-read-receipt-marker nil
 :foreground my/gray)
#+END_SRC

Use normal font size for lurker spam

#+BEGIN_SRC emacs-lisp
(set-face-attribute
 'ement-room-membership nil
 :height 90)
#+END_SRC

*** Matrix room list

Don't show room avatars

#+BEGIN_SRC emacs-lisp
(setq ement-room-list-avatars nil)
#+END_SRC

No bold faces

#+BEGIN_SRC emacs-lisp
(set-face-attribute
 'ement-room-list-unread nil
 :weight 'normal)
#+END_SRC

The default color for direct messages looks too much like an unread
message.

#+BEGIN_SRC emacs-lisp
(set-face-attribute
 'ement-room-list-direct nil
 :foreground my/purple)
#+END_SRC

*** Matrix TODO

- Sending messages via ~M-x ement-room-send-message~ is just awful. I
  want prompt like Circe has
- Showing lag and channels in modeline
- Room membership messages starts with a space and it annoys the hell
  out of me
- Hide the whole headerline. We know the room name from buffer name
- We desperatelly need to have customizable tabulated list format for
  the room list view
- We need to format reply messages better
- Unread indicator in the room list is incorrect
- We need to reduce lurker spam like in Circe
- Configure automatical reconnect, so we don't have to run ~M-x
  ement-connect~ when buffer is not syncing

** Database

We can use ~psql~, for sure. But why leaving Emacs?

#+BEGIN_SRC emacs-lisp
(frostyx/dnf :install "postgresql")
#+END_SRC

See https://truongtx.me/2014/08/23/setup-emacs-as-an-sql-database-client

Almost no configuration is required. For some reason soft line wrapping is
enabled by default, that's just wrong.

#+BEGIN_SRC emacs-lisp
(add-hook 'sql-interactive-mode-hook 'toggle-truncate-lines)
#+END_SRC

And now, let's pre-configure our favorite SQL servers.

#+BEGIN_SRC emacs-lisp
(setq sql-connection-alist
      '((copr-docker
         (sql-product 'postgres)
         (sql-database "postgresql://copr-fe:coprpass@127.0.0.1:5009/coprdb"))))
#+END_SRC

Yes, I am storing a password into a public document, I know. It is a local dev
environment database, so I don't care.

Once we have some connections configured, we can simply run ~sql-connect~ and
pick one.

** Spotify

For quick searches and control, ~spotify-helm-plus~ is the best available
client. It has many shortcomings though. It seems like it requires the official
Spotify client running on the system, it doesn't allow searching albums, and it
doesn't customizing the output with e.g. colors or string format. Other than
that, it works quite alright.

See https://github.com/wandersoncferreira/helm-spotify-plus

#+BEGIN_SRC emacs-lisp
(use-package helm-spotify-plus
  :if workstation-p
  :ensure t)
#+END_SRC

The project is an improvment of the former ~helm-spotify~, so for more
information see the original project.

See https://github.com/krisajenkins/helm-spotify

On the contrary to the documentation, use ~C-z~ to see possible actions, such as
playing the whole album.

The ~helm-spotify-plus~ is only good for a fast control, it doesn't provide any
browsing capabilities (I don't know if as a bug or feature, but it could be
awesome). Hence, let's use some another tool for that.

#+BEGIN_SRC emacs-lisp
(use-package smudge
  :ensure t)
#+END_SRC

Load sensitive tokens from keychain

#+BEGIN_SRC emacs-lisp
(setq smudge-oauth2-client-id (password-store-get "spotify/client-id"))
(setq smudge-oauth2-client-secret (password-store-get "spotify/client-secret"))
#+END_SRC

Use Spotify Connect to be able to control other devices

#+BEGIN_SRC emacs-lisp
(setq smudge-transport 'connect)
#+END_SRC

See the following table for useful commands

| Command                          | Description                    |
|----------------------------------+--------------------------------|
| smudge-my-playlists              | Show your playlists            |
| smudge-track-search              | Search for tracks              |
| smudge-recently-played           | List of recently played tracks |
| smudge-controller-toggle-play    | Play/pause                     |
| smudge-controller-next-track     | Next track                     |
| smudge-controller-previous-track | Previous track                 |
| smudge-select-device             | Select a playback device       |

Let's add a hydra menu, so we don't have to remember the commands or shotcuts.

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-spotify
  (:color blue :quit-key ("q" "SPC") :title "Spotify")
  ("Search"
   (("s" helm-spotify-plus "Search in helm"))

   ;; These are very likely obsolete by Window manager key bindings but it
   ;; doesn't hurt to have a spare in case we are in a foreign environment
   ;; just with Emacs.
   "Control"
   (("p" helm-spotify-plus-toggle-play-pause "Play / Pause")
    ("<" helm-spotify-plus-previous "Previous")
    (">" helm-spotify-plus-next "Next"))

   "Browse"
   (("P" spotify-my-playlists "My playlists")
    ("r" sporify-recently-played "Recently played"))))
#+END_SRC

*** Vuivet

TODO see Vuivet, it should have some spotify features

See:
- http://mihaiolteanu.me/vuiet/
- https://github.com/mihaiolteanu/vuiet

** Bluetooth
See https://github.com/emacsmirror/bluetooth

#+BEGIN_SRC emacs-lisp
(frostyx/dnf :install "bluez-hid2hci")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package bluetooth
  :if workstation-p
  :ensure t)
#+END_SRC

See https://emacs.stackexchange.com/questions/31244/how-can-i-disable-evil-in-help-mode?rq=1

#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'bluetooth-mode 'emacs)
(evil-add-hjkl-bindings bluetooth-mode-map 'emacs)
#+END_SRC

** Pulseaudio

TODO write my own plugin for switching output devices

Here is a bash workflow

See https://askubuntu.com/a/72076

#+BEGIN_SRC bash
# See available output devices (e.g. 1. speakers, 2. bluetooth headphones)
pacmd list-sinks

# Change default output device for new applications
pacmd set-default-sink 2

# See all currently running applications having output
# e.g. chromium with id 1712
pacmd list-sink-inputs

# Then go through all those applications and switch their outpud device
pacmd move-sink-input 1712 1
#+END_SRC

* Beyond Emacs
** Edit with Emacs (in Google Chrome)
/Edit with Emacs/ is a Google Chrome extension allowing to pop-up a new Emacs
frame to edit a textarea.

See https://chrome.google.com/extensions/detail/ljobjlafonikaiipfkggjbhkghgicgoh

The usage is easy, just right-click a ~<textarea>~ and click ~Edit with
Emacs~. This feature doesn't work for "rich editors", e.g. Gmail, Grammarly,
etherpads, etc.

Some configuration is required on the Emacs part.

See https://github.com/stsquad/emacs_chrome

#+BEGIN_SRC emacs-lisp
(use-package edit-server
  :if workstation-p
  :ensure t
  :config
  (edit-server-start))
#+END_SRC

I probably don't need (most of) this configuration because of using a tiling
window manager. The size and position of this new frame will be determined
solely by my WM workspace layout. I am leaving it here in case I was forced to
work in a shitty DE.

#+BEGIN_SRC emacs-lisp
(setq edit-server-new-frame-alist
      '((name . "Edit with Emacs FRAME")
        (top . 200)
        (left . 200)
        (width . 80)
        (height . 25)
        (minibuffer . t)
        (menu-bar-lines . t)
        (window-system . x)))
#+END_SRC

* Things to do
** TODO Dired sorting per directory
   https://www.gnu.org/software/emacs/manual/html_node/emacs/Directory-Variables.html

** TODO Dired image previews
   http://pragmaticemacs.com/emacs/quickly-preview-images-and-other-files-with-peep-dired/
   https://lucidmanager.org/productivity/using-emacs-image-dired/

** TODO Youtube downloader
   https://www.reddit.com/r/emacs/comments/hxbmda/ytdl_an_emacs_interface_for_youtubedl/
   https://github.com/skeeto/youtube-dl-emacs

** TODO Dired open multiple files at once
https://www.reddit.com/r/emacs/comments/egbz7i/opening_multiple_windows_at_once_from_dired/

** Bugs

I would consider this configuration mature enough and not experimental anymore
once these TODO items are done. Try ~C-c C-c~ to toggle them.

- [ ] Documentation for each piece of emacs-lisp code
- [ ] Correct indentation for standard filetypes
  - [ ] When writting a checklist in org mode, newline inserts 4 spaces,
        which is wrong
  - [ ] Unify Evil's ~O~, ~RET~ for newlines plus ~TAB~ and ~>>~
  - [ ] Inteligent behavior of backspace
- [ ] Correct indentation for non-standard filetypes, such as ~.elm~
- [ ] Unified auto-completion across all programming languages
- [ ] Not messing up whitespace by either removing or showing it
- [X] Working snippets for e.g. ~ipdb~
- [ ] Code cleanup, unified way to do things
  - [ ] All package imports using ~use-package~, even the local ones
  - [ ] Key bindings - ~:bind~ vs ~:config~ vs whatever else
  - [ ] Get rid of all ~:config nil~ lines
  - [ ] Closing brackets where they should be
- [ ] Evil ~C-o~ jumps to a file regardles of a project
- [ ] File backups should go to ~/.emacs/swp, not to mess git repos
- [ ] Searching with ~/~ is somehow broken and doesn't support arrow keys


These are less important, but we still want to keep track of them.

- [ ] These checklists doesn't render proprely at GitHub
- [ ] Inline code blocks containing commas doesn't render properly on GitHub
- [ ] Spell checker
- [ ] ~:set colorcolumn=120~ alternative (should be built in Emacs 27)
- [ ] Figure out how to have multiple Emacs windows/instances in order to
      utilize window manager workspaces/groups and multiple monitors
- [X] Generate TOC list


But ... is it even worth it? ... Nope. It is fun though!

#+CAPTION: Is It Worth The Time - xkcd.com/1205
[[./img/is_it_worth_the_time.png]]

Hint: Use ~M-x org-toggle-inline-images~ to see images in Emacs

* Resources
** Other people configs

- https://github.com/angrybacon/dotemacs/blob/master/dotemacs.org
- https://wolfecub.github.io/dotfiles/
- https://jamiecollinson.com/blog/my-emacs-config/
- https://emacs.nasy.moe/
- https://se30.xyz/conf.html
- https://depp.brause.cc/dotemacs/#org22ed5c7 (wasamasa)

** Videos

- DistroTube - https://www.youtube.com/channel/UCVls1GmFKf6WlTraIb_IaJg
- Protesilaos Stavrou - https://www.youtube.com/channel/UC0uTPqBCFIpZxlz_Lv1tk_g
