#+TITLE: FrostyX's Emacs configuration
#+AUTHOR: Jakub Kadlčík


This Emacs configuration is a mess. I am a newbie trying to hack things together
and experiment. Do not take anything from this configuration unles you know what
you are doing. Because the odds are, that I am not.

* Table of Contents :TOC:
- [[#things-to-do][Things to do]]
- [[#defaults][Defaults]]
- [[#package-management][Package management]]
- [[#secrets][Secrets]]
- [[#living-in-evil][Living in Evil]]
  - [[#evil-leader][Evil leader]]
  - [[#evil-mode][Evil Mode]]
  - [[#evil-packages][Evil packages]]
  - [[#vim-keybindings-everywhere][Vim keybindings everywhere]]
  - [[#more-vim-compatibility][More Vim compatibility]]
  - [[#custom-evil-keybindings][Custom Evil keybindings]]
  - [[#custom-evil-commands][Custom Evil commands]]
- [[#interface][Interface]]
  - [[#gui][GUI]]
  - [[#themes][Themes]]
  - [[#fonts][Fonts]]
  - [[#ux][UX]]
- [[#project-management][Project management]]
- [[#sessions][Sessions]]
- [[#development][Development]]
  - [[#completion][Completion]]
  - [[#whitespace][Whitespace]]
  - [[#languages][Languages]]
  - [[#lsp][LSP]]
- [[#writing][Writing]]
- [[#applications][Applications]]
  - [[#file-manager][File manager]]
  - [[#web][Web]]
  - [[#email][Email]]
  - [[#rss][RSS]]
  - [[#spotify][Spotify]]
  - [[#networkmanager][NetworkManager]]
  - [[#bluetooth][Bluetooth]]
  - [[#pulseaudio][Pulseaudio]]
- [[#resources][Resources]]
  - [[#other-people-configs][Other people configs]]
  - [[#videos][Videos]]

* Things to do

I would consider this configuration mature enough and not experimental anymore
once these TODO items are done. Try ~C-c C-c~ to toggle them.

- [ ] Documentation for each piece of emacs-lisp code
- [ ] Correct indentation for standard filetypes
  - [ ] When writting a checklist in org mode, newline inserts 4 spaces,
        which is wrong
  - [ ] Unify Evil's ~O~, ~RET~ for newlines plus ~TAB~ and ~>>~
  - [ ] Inteligent behavior of backspace
- [ ] Correct indentation for non-standard filetypes, such as ~.elm~
- [ ] Unified auto-completion across all programming languages
- [ ] Not messing up whitespace by either removing or showing it
- [X] Working snippets for e.g. ~ipdb~
- [ ] Code cleanup, unified way to do things
  - [ ] All package imports using ~use-package~, even the local ones
  - [ ] Key bindings - ~:bind~ vs ~:config~ vs whatever else
  - [ ] Get rid of all ~:config nil~ lines
  - [ ] Closing brackets where they should be
- [ ] Evil ~C-o~ jumps to a file regardles of a project
- [ ] File backups should go to ~/.emacs/swp, not to mess git repos
- [ ] Searching with ~/~ is somehow broken and doesn't support arrow keys


These are less important, but we still want to keep track of them.

- [ ] These checklists doesn't render proprely at GitHub
- [ ] Inline code blocks containing commas doesn't render properly on GitHub
- [ ] Spell checker
- [ ] ~:set colorcolumn=120~ alternative (should be built in Emacs 27)
- [ ] Figure out how to have multiple Emacs windows/instances in order to
      utilize window manager workspaces/groups and multiple monitors
- [X] Generate TOC list


But ... is it even worth it? ... Nope. It is fun though!

#+CAPTION: Is It Worth The Time - xkcd.com/1205
[[./img/is_it_worth_the_time.png]]

Hint: Use ~M-x org-toggle-inline-images~ to see images in Emacs

* Oh-shit buttons

In case you do something and have no idea how to save yourself.

Reset variable to its default value, press ~M-:~ and run:

#+BEGIN_SRC
(custom-reevaluate-setting 'emms-player-next-function)
#+END_SRC

* Defaults

#+BEGIN_SRC emacs-lisp
;; https://www.emacswiki.org/emacs/AutoPairs
;; TODO try https://github.com/Fuco1/smartparens instead
(electric-pair-mode)


;; Middle-click paste where cursor is, don't care about mouse position
;; https://superuser.com/questions/330849/can-i-tell-emacs-to-paste-middle-mouse-button-on-the-cursor-position
(setq mouse-yank-at-point t)


;; Automatically reload changed files
;; https://stackoverflow.com/q/1480572/3285282
(global-auto-revert-mode t)


;; keyboard scroll one line at a time
;; scroll when cursor is five lines from the edge
;; and don't ever recenter the cursor when scrolling
(setq scroll-step 1)
(setq scroll-margin 5)
(setq scroll-conservatively 101)


;; Don't throw "Invalid coding system" errors on me when writting a file
(define-coding-system-alias 'UTF-8 'utf-8)


;; Don't mess CWD with #foo.py# and foo.py~ files
;; https://emacs.stackexchange.com/a/34
;; (setq backup-directory-alist '(("." . "~/MyEmacsBackups")))
;; (setq backup-directory-alist '("~/MyEmacsBackups"))
;; (setq backup-directory-alist `(("." . "~/MyEmacsBackups")))


;; https://stackoverflow.com/a/18330742/3285282
(defvar --backup-directory (concat user-emacs-directory "MyEmacsBackups"))
(if (not (file-exists-p --backup-directory))
        (make-directory --backup-directory t))
(setq backup-directory-alist `(("." . ,--backup-directory)))
(setq backup-directory-alist `((,--backup-directory)))
(setq make-backup-files t               ; backup of a file the first time it is saved.
      backup-by-copying t               ; don't clobber symlinks
      version-control t                 ; version numbers for backup files
      delete-old-versions t             ; delete excess backup files silently
      delete-by-moving-to-trash t
      kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
      kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
      auto-save-default t               ; auto-save every buffer that visits a file
      auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
      auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
      )
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook #'display-line-numbers-mode)
(save-place-mode 1)
#+END_SRC

Let's have some funny message on the top of the ~*scratch*~ buffer.

#+BEGIN_SRC emacs-lisp
(setq initial-scratch-message ";; Do you even lisp, bro? ಠ_ಠ\n\n\n")
#+END_SRC


We don't want to quit emacs. Ever! Sometimes it happens to me, that I
accidentally type ~:wq~ because I want to close the current buffer but don't
realize that I am not in any split, so this is my last visible buffer. In such
case, Emacs gets killed and it sucks so bad (because I have ten eyebrowse
workspaces full of things, they are just not currently visible). So, let's take
this safety measure and ask everytime before quiting.

#+BEGIN_SRC emacs-lisp
(setq confirm-kill-emacs 'y-or-n-p)
#+END_SRC

* Package management

We want to automatically update Emacs packages in order to avoid annoying warnings
during startup, that some package is recommended to be updated.

Update automatically every night, don't ask for confirmation and don't bother us
with update at Emacs startup.

See https://emacs.stackexchange.com/a/31904

#+BEGIN_SRC emacs-lisp
(use-package auto-package-update
   :ensure t
   :config
   (setq auto-package-update-delete-old-versions t
         auto-package-update-interval 365
         auto-package-update-prompt-before-update nil
         auto-package-update-hide-results t)
   (auto-package-update-at-time "04:00"))
#+END_SRC

Unfortunatelly updating takes around two minutes which is long enough to get
disconnected from IRC, which is super annoying. As a temporary workaround let's
update only once a year. We are waiting for async updates.

See https://github.com/rranelli/auto-package-update.el/issues/39

When the update is failing, it starts to ask whether to kill the buffers
or what. Don't do that.

See https://emacs.stackexchange.com/q/14509

#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions nil)
#+END_SRC

* Secrets

Please do not hardcode your passwords or secret information into source code.
Store them into some keyring application (e.g. ~pass~) and query them instead.
This solution provides many advantages:

1. You can safely share your configs publicly without exposing sensitive data,
   /*duh*/
2. No messing with partially commiting files just to leave the sensitive parts
3. In comparison to including a git ignored file with password definitions,
   keyrings have strong encryption

See:
- https://www.passwordstore.org/
- https://medium.com/@chasinglogic/the-definitive-guide-to-password-store-c337a8f023a1

#+BEGIN_SRC emacs-lisp
(use-package password-store
  :ensure t)
#+END_SRC

* Living in Evil

@TODO link the great blog post explaining emacs key bindings

TODO rant about Emacs key bindings

TODO xkcd image mocking Emacs keybindings

See https://github.com/noctuid/evil-guide


These two needs to be set before we even try to load Evil (or ~evil-collection~ or
~evil-leader~).

See
- https://github.com/emacs-evil/evil-collection#installation
- https://github.com/emacs-evil/evil-collection/issues/215

#+BEGIN_SRC emacs-lisp
(setq evil-want-keybinding nil)
(setq evil-want-integration t)
#+END_SRC

** Evil leader
A common way to define custom key bindings for Vim ~NORMAL~ mode is by utilizing
so called ~<leader>~ key. By default it is mapped to ~\~ but can be remaped to
something else (in my case to comma). Custom mappings are then defined a sequence
of ~<leader>~ key followed by one or more letters. An example can be ~\ga~ for
~git add~ and ~\gc~ for ~git commit~.

For Emacs, this functionality is implemented in ~evil-leader~ package.

See https://github.com/cofi/evil-leader

According to documentation we need to enable ~evil-leader-mode~ before ~evil-mode~.

#+BEGIN_QUOTE
Note: You should enable global-evil-leader-mode before you enable evil-mode,
otherwise evil-leader won’t be enabled in initial buffers (*scratch*, *Messages*, …).
#+END_QUOTE

I don't know about these, but more importantly ~evil-leader~ needs to go first,
otherwise it doesn't work in ~org-mode~.

#+BEGIN_SRC emacs-lisp
(use-package evil-leader
  :ensure t
  :config
  (evil-leader/set-leader ",")
  (global-evil-leader-mode))
#+END_SRC

** Evil Mode

See:
- https://github.com/emacs-evil/evil
- https://www.reddit.com/r/emacs/comments/726p7i/evil_mode_and_use_package/dnh3338?utm_source=share&utm_medium=web2x

#+BEGIN_SRC emacs-lisp
(use-package evil
  :ensure t ;; install the evil package if not installed
  :init ;; tweak evil's configuration before loading it
  (setq evil-search-module 'evil-search)
  (setq evil-ex-complete-emacs-commands nil)
  (setq evil-vsplit-window-right t)
  (setq evil-split-window-below t)
  (setq evil-shift-round nil)
  (setq evil-want-C-u-scroll t)


  (setq evil-ex-set-initial-state 'normal)

  :config ;; tweak evil after loading it
  (evil-mode))
#+END_SRC

Let's unbind arrow keys for movement. I exclusively use ~hjkl~, so the arrow
keys for movement are useless. On the other hand, they might come handy for
other applications such as IRC client to show previous messages in the prompt or
for terminal application to show previous commands.

#+BEGIN_SRC emacs-lisp
(eval-after-load "evil-maps"
  (dolist (map '(evil-motion-state-map
                 evil-insert-state-map
                 evil-emacs-state-map))
    (define-key (eval map) (kbd "<up>") nil)
    (define-key (eval map) (kbd "<down>") nil)
    (define-key (eval map) (kbd "<left>") nil)
    (define-key (eval map) (kbd "<right>") nil)))
#+END_SRC

@TODO this ^^ requires restarting ~evil-mode~ to have an effect

** Evil packages

TODO evil-indent-surround

#+BEGIN_SRC emacs-lisp
;; (use-package evil-surround
;;   :ensure t
;;   :config
;;   (global-evil-surround-mode))
#+END_SRC

TODO evil-indent-textobject

#+BEGIN_SRC emacs-lisp
;; ;; @FIXME missing config
;; (use-package evil-indent-textobject
;;   :ensure t)
#+END_SRC


When programming, it is usefull to comment-out pieces of a code to temporarily disable them.
This is valuable when refactoring something and deciding what implementation to use, when
temporarily adding and then enabling/disabling breakpoints, etc. I do it thousand times a day.
Instead of removing the lines and then undoing back, or maybe weirdly commenting the code
line by line, use ~evil-commentary~.

See https://github.com/linktohack/evil-commentary

The usage is straightforward. In ~NORMAL~ mode press ~gcc~ to comment the current line of code.
If it is already commented, it will uncomment it. This behavior is same for all the following
commands. To comment e.g. next 3 lines, use ~3gcc~. To comment a ~VISUAL~ selection, press
~gc~. Another useful option is to do ~gy~ which comments the selection but yanks it first.

#+BEGIN_SRC emacs-lisp
(use-package evil-commentary
  :ensure t
  :config
  (evil-commentary-mode))
#+END_SRC

** Vim keybindings everywhere

#+BEGIN_SRC emacs-lisp
(use-package evil-collection
  :after evil
  :ensure t
  :config
  (evil-collection-init))

;; use evil mode in the buffer created from calling `M-x list-packages'.
;; https://blog.aaronbieber.com/2016/01/23/living-in-evil.html#adding-hjkl-bindings-
(evil-add-hjkl-bindings occur-mode-map 'emacs
  (kbd "/")       'evil-search-forward
  (kbd "n")       'evil-search-next
  (kbd "N")       'evil-search-previous
  (kbd "C-d")     'evil-scroll-down
  (kbd "C-u")     'evil-scroll-up
  (kbd "C-w C-w") 'other-window)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq evil-default-state 'normal) ;; changes default state to emacs
#+END_SRC

TODO ctrl+w hjkl is too slow

#+BEGIN_SRC emacs-lisp
(define-key evil-normal-state-map (kbd "C-h") 'evil-window-left)
(define-key evil-normal-state-map (kbd "C-j") 'evil-window-down)
(define-key evil-normal-state-map (kbd "C-k") 'evil-window-up)
(define-key evil-normal-state-map (kbd "C-l") 'evil-window-right)
#+END_SRC

TODO package manager key bindings, these needs to go somewhere else

See https://www.reddit.com/r/emacs/comments/7dsm0j/how_to_get_evilmode_hjkl_to_work_inside_mx/

#+BEGIN_SRC emacs-lisp
(evil-define-key 'normal package-menu-mode-map (kbd "m") #'package-menu-mark-install)
(evil-define-key 'normal package-menu-mode-map (kbd "u") #'package-menu-mark-unmark)
(evil-define-key 'normal package-menu-mode-map (kbd "x") #'package-menu-execute)
#+END_SRC

** More Vim compatibility

#+BEGIN_SRC emacs-lisp
;; https://emacsredux.com/blog/2014/08/27/a-peek-at-emacs-24-dot-4-superword-mode/
;; #@FIXME using this manually in a python file works, but this config setting not
;; Probably `global-*' mode settings will be required here. Wihout global, the setting
;; is only for the current buffer
;; (superword-mode)
(global-superword-mode)


;; https://emacs.stackexchange.com/a/9584
;; Superword mode seems to apply only on searching, adding also this,
;; to get w, yiw, dw, etc working as expected
(modify-syntax-entry ?_ "w")

;; https://github.com/syl20bnr/spacemacs/blob/develop/doc/FAQ.org#include-underscores-in-word-motions
;; (add-hook 'prog-mode-hook #'(lambda () (modify-syntax-entry ?_ "w")))
;; (add-hook 'mhtml-mode-hook #'(lambda () (modify-syntax-entry ?_ "w")))

;; https://emacs.stackexchange.com/questions/9583/how-to-treat-underscore-as-part-of-the-word/20717#20717
;; (with-eval-after-load 'evil
;;     (defalias #'forward-evil-word #'forward-evil-symbol)
;;     ;; make evil-search-word look for symbol rather than word boundaries
;;     (setq-default evil-symbol-word-search t))
#+END_SRC


See https://www.reddit.com/r/emacs/comments/86iq3w/evil_cw_o_toggle_windows/

#+BEGIN_SRC emacs-lisp
(defun toggle-fullscreen ()
  (interactive)
  (if (window-parent)
      (delete-other-windows)
    (winner-undo)))

(define-key evil-normal-state-map (kbd "C-w o") 'toggle-fullscreen)
#+END_SRC

** Custom Evil keybindings

Emacs provides so many ways to create custom keybindings and to run commands in
general (e.g. emacs key-chords, helm, hydra, evil-leader, etc). You will probably
find multiple shortcuts in this document for executing a same command. One of them
will them will be compatible with my Vim cofiguration which has been wired to my
brain from a decade of using it. The other shortcuts will be more Emacsy.

TODO The question is - should we define them here or within their use-package definitions?

TODO projectile

#+BEGIN_SRC emacs-lisp
(evil-leader/set-key
  "f" 'helm-projectile
  "p" 'helm-projectile-switch-project)
#+END_SRC

Sometimes it happens that ~helm-projectile~ or ~helm-projectile-find-file~
suddenly stops working for a project and nothing (including Emacs restart)
helps. The only solution I accidentally found is running ~helm-ls-git-ls~
command, close it, and then finding files works again.

See https://github.com/emacs-helm/helm-ls-git

TODO magit

#+BEGIN_SRC emacs-lisp
(evil-leader/set-key
  "ga" 'magit-stage-file
  "gc" 'magit-commit  ;; Maybe magit-commit-create
  "gp" 'magit-push-current) ;; @TODO still asks for something, use more specific function
#+END_SRC

Random garbage

#+BEGIN_SRC emacs-lisp
(evil-leader/set-key
  "w" 'evil-window-vsplit
  "def" 'evil-jump-to-tag)
#+END_SRC

** Custom Evil commands

Evil even allows you to create your own colon commands. I don't need it, most folks
probably don't need it, but you got to admit it's pretty spectacular.

See https://emacs.stackexchange.com/questions/10350/how-can-i-add-a-new-colon-command-to-evil

This command is mainly an example how to do it. I have probably never used it.

#+BEGIN_SRC emacs-lisp
(eval-after-load 'evil-ex
  '(evil-ex-define-cmd "Gbrowse" 'browse-at-remote))
#+END_SRC

* Window management

Emacs default window management makes me want to kill myself. After six months,
I still have absolutely no idea how it works. New windows literaly appear on the
least expected positions, they randomly change, some of them even break the
current split configuration. It seems like the internal window manager is trying
so hard to be smart but for me, it has the exactly opposite effect.

Meanwhile, this magic is not necessary (let alone useful) at all. Maybe it is
for vanilla Emacs but in Evil world, the splits and window management is
just amazing.

Let's just open everything in the current window, shall we? I can split manually
if I want to.

We need to configure special buffers separately because it is going to be done
based on ther names. They are special and their names do not change.

For explanation of how ~display-buffer-alist~ works, see
https://www.simplify.ba/articles/2016/01/25/display-buffer-alist/

For other pratical code samples see
https://reflexivereflection.com/posts/2018-04-06-disabling-emacs-window-management.html

#+BEGIN_SRC emacs-lisp
(setq display-buffer-alist
      '(("shell.*" (display-buffer-same-window) ())
        (".*" (display-buffer-reuse-window
               display-buffer-same-window)
         (reusable-frames . t))))
#+END_SRC

The ~display-buffer-alist~ isn't respected by every command, so we need to
specifically set these.

Make sure man pages open in the current window.
See https://stackoverflow.com/a/7787941/3285282

#+BEGIN_SRC emacs-lisp
(setq Man-notify-method 'pushy)
#+END_SRC

* Interface

** GUI

Disable all the GUI nonsense. Even though we are running graphical version of Emacs,
we want to be #mouseless and have the UI to look as close to terminal as possible.

Get rid of menu, scrollbars, toolbars and everything that can be clicked on.

#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(customize-set-variable 'scroll-bar-mode nil)
(customize-set-variable 'horizontal-scroll-bar-mode nil)
#+END_SRC

** Themes

At this point, my whole desktop environment uses ~base16-chalk~

See http://chriskempson.com/projects/base16/

#+BEGIN_SRC emacs-lisp
(use-package base16-theme
  :ensure t
  :config
  (load-theme 'base16-chalk t))
#+END_SRC

** Colors

Let's define our set of colors based on current theme, so we can easily use them
for customizing third-party packages.

See http://chriskempson.com/projects/base16/#styling-guidelines

#+BEGIN_SRC emacs-lisp
(setq my/black (plist-get base16-chalk-colors :base00)
      my/gray (plist-get base16-chalk-colors :base01)
      my/lgray (plist-get base16-chalk-colors :base03)
      ;; ... grayish colors from base02 to base06
      my/white (plist-get base16-chalk-colors :base07)
      my/red (plist-get base16-chalk-colors :base08)
      my/orange (plist-get base16-chalk-colors :base09)
      my/yellow (plist-get base16-chalk-colors :base0A)
      my/green (plist-get base16-chalk-colors :base0B)
      my/lblue (plist-get base16-chalk-colors :base0C)
      my/blue (plist-get base16-chalk-colors :base0D)
      my/purple (plist-get base16-chalk-colors :base0E)
      my/brown (plist-get base16-chalk-colors :base0F))
#+END_SRC

** Fonts

#+BEGIN_SRC emacs-lisp
(set-face-attribute
  'default nil
  :family "vera sans"
  :height 90
  :weight 'normal
  :width 'normal)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'lazy-highlight nil :background my/orange
                                        :foreground my/gray)
#+END_SRC

Besides normal fonts we also want to setup some icon fonts. Personally, I like
~Font Awesome~ the best. It is really easy to use and it dominates in the realm
of website icons so it is like killing two birds with one stone.

See https://github.com/emacsorphanage/fontawesome

#+BEGIN_SRC emacs-lisp
(use-package fontawesome
  :ensure t)
#+END_SRC

By default ~Font Awesome~ icons show quite strangely. It seems that all icons
work, it's just they are displayed under wrong names. In ~M-x helm-fontawesome~
it works properly though. The following setting fixes it.

See https://github.com/emacsorphanage/fontawesome/issues/12#issuecomment-284193735

#+BEGIN_SRC emacs-lisp
(set-fontset-font t 'unicode "FontAwesome" nil 'prepend)
#+END_SRC

** UX

*** Modeline

#+BEGIN_SRC emacs-lisp
(use-package spaceline
  :ensure t
  :config)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package spaceline-config
  :ensure spaceline
  :config
  (spaceline-helm-mode 1)
  (spaceline-spacemacs-theme)
  (spaceline-toggle-org-clock-on)
  (spaceline-toggle-minor-modes-off)
  (spaceline-toggle-version-control-on)
  (spaceline-toggle-buffer-size-off)
  (spaceline-toggle-buffer-encoding-abbrev-off)
  (spaceline-toggle-buffer-position-on))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq spaceline-highlight-face-func 'spaceline-highlight-face-evil-state)
(set-face-attribute 'spaceline-evil-normal nil :background my/gray :foreground my/orange)
(set-face-attribute 'spaceline-evil-emacs nil :background my/gray :foreground my/blue)
(set-face-attribute 'spaceline-evil-insert nil :background my/gray :foreground my/green)
(set-face-attribute 'spaceline-evil-replace nil :background my/gray :foreground my/blue)
(set-face-attribute 'spaceline-evil-motion nil :background my/gray :foreground my/blue)
(set-face-attribute 'spaceline-evil-visual nil :background my/gray :foreground my/purple)
#+END_SRC


See:
- https://dev.to/gonsie/beautifying-the-mode-line-3k10
- https://github.com/TheBB/spaceline/issues/20#issuecomment-150488572

#+BEGIN_SRC emacs-lisp
(spaceline-define-segment version-control
  (when vc-mode
    (let ((gitlogo (replace-regexp-in-string "^ Git." "  " vc-mode)))
      (powerline-raw (s-trim gitlogo)))))
#+END_SRC

After making changes in spaceline segments, it needs to be recompiled, otherwise
they don't take an effect.

#+BEGIN_SRC emacs-lisp
(spaceline-compile)
#+END_SRC

*** Helm

#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure t
  :config
  (helm-mode 1)
  (setq helm-autoresize-mode t)
  (setq helm-buffer-max-length 40)
  (setq helm-locate-fuzzy-match t)


  (global-set-key (kbd "M-x") #'helm-M-x)
  ; (define-key helm-map (kbd "S-SPC") 'helm-toggle-visible-mark)
  ; (define-key helm-find-files-map (kbd "C-k") 'helm-find-files-up-one-level)

  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to do persistent action
  (define-key helm-map (kbd "TAB") #'helm-execute-persistent-action)
  (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

  ; http://cachestocaches.com/2016/12/vim-within-emacs-anecdotal-guide/
  (define-key helm-map (kbd "C-j") 'helm-next-line)
  (define-key helm-map (kbd "C-k") 'helm-previous-line)
  (define-key helm-map (kbd "C-h") 'helm-next-source)

  (define-key helm-map [escape] 'helm-keyboard-quit)

  ; (define-key helm-map (kbd "C-S-h") 'describe-key)
  ; (define-key helm-map (kbd "C-l") (kbd "RET"))
  ; (dolist (keymap (list helm-find-files-map helm-read-file-map))
        ; (define-key keymap (kbd "C-l") 'helm-execute-persistent-action)
        ; (define-key keymap (kbd "C-h") 'helm-find-files-up-one-level)
        ; (define-key keymap (kbd "C-S-h") 'describe-key))


)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package helm-posframe
  :ensure t
  :disabled
  :config
  (helm-posframe-enable)
  (setq helm-posframe-poshandler
        #'posframe-poshandler-frame-center)
  (setq helm-posframe-width 200)
  (setq helm-posframe-height 600)
  (setq helm-posframe-parameters
        '((left-fringe . 10)
          (right-fringe . 10))))
#+END_SRC

Unfortunatelly, ~helm-posframe~ is quite buggy and breaks tab-completion for
~M-:~, takes a lot of time to appear, sometimes it appears empty or
whatelse. Let's try to stick with a small helm window at the bottom.

See https://github.com/emacs-helm/helm/issues/2039#issuecomment-390077931

#+BEGIN_SRC emacs-lisp
(defvar spacemacs-helm-display-help-buffer-regexp '("\\*.*Helm.*Help.*\\*"))
(defvar spacemacs-helm-display-buffer-regexp `("\\*.*helm.*\\*"
                                               (display-buffer-in-side-window)
                                               (inhibit-same-window . nil)
                                               (side . bottom)
                                               (window-width . 0.6)
                                               (window-height . 0.6)))

(defun display-helm-at-bottom (buffer &optional _resume)
  (let ((display-buffer-alist (list spacemacs-helm-display-help-buffer-regexp
                                    spacemacs-helm-display-buffer-regexp)))
    (display-buffer buffer)))
(setq helm-display-function 'display-helm-at-bottom)
#+END_SRC

And finally, we want to show a limited number of results.

See https://github.com/emacs-helm/helm/wiki/helm-autoresize

#+BEGIN_SRC emacs-lisp
(helm-autoresize-mode 1)
(setq helm-autoresize-max-height 40)
(setq helm-autoresize-min-height 40)
#+END_SRC

Buffer management is a bread and butter of every text editor. This is true even
more for Emacs because we tend to live in it. Everything is a buffer.
I don't want to navigate through a mess of all things that I've opened this week
every time I want to switch a buffer.

Most times, there is a high probability to guess, what we are currently
interested in. Are we working in a project? Are we in the dired mode? Are we
chatting on IRC?

#+BEGIN_SRC emacs-lisp
(defun my/smart-buffers-list ()
  (interactive)
  (cond ((derived-mode-p 'lui-mode) (my/circe-switch-to-buffer))
        ((projectile-project-root) (helm-projectile-switch-to-buffer))
        (t (helm-buffers-list))))
#+END_SRC

We have a key binding for our smarty-pants buffer-switching command which should
be suitable for 99% of cases and for the rest, there is a fallback showing all
open buffers without any filter.

#+BEGIN_SRC emacs-lisp
(define-key evil-normal-state-map (kbd ";") 'my/smart-buffers-list)
(define-key evil-normal-state-map (kbd ",;") 'helm-buffers-list)
#+END_SRC

*** Hydra

Hydra, a mythical Greek creature ultimatelly killed by Heracles. The beast
posseses many heads and for every head that is chopped off, Hydra will seal
the wound and grow a two additional heads from it.

What a beautiful /real-life/ example of binary trees. Hydras in Emacs lives
in the same spirit. They are a pop-up menus that you may know from Spacemacs
or Doom Emacs. The menu defines single-letter key bindings that can either
execute a function or spawn another menu.

This has many neat use-cases. You can create menus to simply launch applications,
create a settings menu to easily toggle features (or minor modes), create
shortcuts for commonly used commands, etc.

You can also completly replace all Emacs key bindings because they are allegedly
dangerous for your hands. Let's say that we use space for spawning the hydra
menu. You can implement it in a way, that you can avoid pressing unnecessary
~M-~ and ~C-~ chords (which is actually called ~god-mode~). You might want to
an simpler version of that, e.g.

| Default Chord   | Possible Hydra Alternative |
|-----------------+----------------------------|
| C-a             | <SPC> a                    |
| C-x C-s         | <SPC> xs                   |
| C-a C-k C-n C-y | <SPC> akny                 |

See more about ~god-mode~ https://chrisdone.com/posts/god-mode/

Let's install just the ~hydra~ package and keep it simple.

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :ensure t
  :bind
  ("C-SPC" . hydra-main/body)
  :config
  (define-key evil-normal-state-map (kbd "SPC") 'hydra-main/body)
  :custom
  (hydra-default-hint nil))
#+END_SRC

**** Additional Hydra packages

I would really love to use hydra in posframe, but it doesn't work properly

See
- https://github.com/Ladicle/hydra-posframe
- https://github.com/jerrypnz/major-mode-hydra.el/issues/30

#+BEGIN_SRC emacs-lisp
;; (use-package hydra-posframe
;;   :load-path "/home/jkadlcik/git/hydra-posframe"
;;   :hook
;;   (after-init . hydra-posframe-enable))
#+END_SRC

The default way to define hydras is too clumsy and involves a lot of tedious
string formatting by hand. As a consequence it is really painful to add new
items or delete the existing ones. Let's install ~pretty-hydra~ instead,
if allows us to define hydras as lists of columns.

#+BEGIN_SRC emacs-lisp
(use-package pretty-hydra
  :ensure t)
#+END_SRC

**** Main Hydra Menu

Hydra main entry-point allowing us acces to other hydras.

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-main
  (:color blue :quit-key ("q" "SPC") :title "Hydra")
  ("Misc"
   (("m" major-mode-hydra "major mode")
    ("a" hydra-applications/body "applications")
    ("o" browse-url-at-point "open URL")
    ("z" hydra-presentations/body "presentations"))

   "Workspaces"
   (("e" eyebrowse-switch-to-window-config "switch workspace")
    ("E" hydra-eyebrowse/body "eyebrowse"))

   "Projects"
   (("p" helm-projectile-switch-project "switch project")
    ("P" hydra-project/body "projectile"))

   "File Management"
   (("d" dired-jump "open dired in the current directory")
    ("D" hydra-dired/body "dired"))

   "Git"
   (("g" magit-status "magit")
    ("G" hydra-magit/body "more magit options"))

   "Emacs"
   (("r" (load-file user-init-file) "reload configuration")
    ("c" hydra-configuration/body "reload configuration"))))
#+END_SRC

TODO define a hydra menu for creating frames (having also specific purpose
     frames such as for IRC, Mail and RSS

**** Presentations

Hydra definitions useful for presentations.

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-presentations
  (:color blue :quit-key ("q" "SPC") :title "Presentations")
  ("Actions"
   (("l" text-scale-decrease "lesser")
    ("g" text-scale-increase "greated"))))
#+END_SRC

Hydra definitions for ~projectile~ package.

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-project
  (:color blue :quit-key ("q" "SPC") :title "Project Management")
  ("Actions"
   (("d" projectile-discover-projects-in-search-path "discover new projects"))))
#+END_SRC

**** Eyebrowse

Hydra definitions for Eyebrowse commands.

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-eyebrowse
  (:color blue :quit-key ("q" "SPC") :title "Presentations")
  ("Eyebrowse"
   (("e" eyebrowse-switch-to-window-config "Switch to config")
    ("l" eyebrowse-last-window-config "Switch to the latest window config")
    ("c" eyebrowse-create-named-window-config "Create a new config")
    ("r" eyebrowse-rename-window-config "Rename a new config")
    ("d" eyebrowse-close-window-config "Destroy a window config"))))
#+END_SRC

**** Dired

Hydra definition for ~dired~ package.

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-dired
  (:color blue :quit-key ("q" "SPC") :title "Dired")
  ("Open in"
   (("." dired-jump "current directory")
    ("~" (lambda () (interactive) (dired "~/")) "home directory")
    ("/" (lambda () (interactive) (dired "/")) "root directory")
    ("p" (lambda () (interactive) (dired (projectile-project-root)))))))
#+END_SRC

**** Magit

Hydra definition for ~magit~ package.

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-magit
  (:color blue :quit-key ("q" "SPC") :title "Magit")
  ("Open in"
   (("g" magit-status "magit")
    ("b" magit-branch-checkout))))
#+END_SRC

**** Flycheck

Hydra definition for flycheck or other linter

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-linter
  (:color blue :quit-key ("q" "SPC") :title "Linter")
  ("Flycheck"
   (("v" flycheck-verify-setup "verify setup")
    ("t" flycheck-mode "toggle on/off"))

   "Error"
   (("<" flycheck-previous-error "previous")
    (">" flycheck-next-error "next")
    ("l" flycheck-list-errors "list")
    ("o" nil "open in browser")
    ("i" pylint-disable-current-warning "ignore"))))
#+END_SRC

**** Applications

Hydra launcher for applications

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-applications
  (:color blue :quit-key ("q" "SPC") :title "Applications")
  ("Launch"
   (("r" elfeed "RSS (elfeed)")
    ("w" eww "web (eww)")
    ("e" mu4e "email (mu4e)")
    ("s" hydra-spotify/body "Spotify"))))
#+END_SRC

**** Configuration

Hydra for configuration/settings/toggle options

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-configuration
  (:color blue :quit-key ("q" "SPC") :title "Configuration")
  ("Vertical Line"
   (("v" turn-off-fci-mode "No vertical line")
    ("8" (my/colorcolumn 80) "80 characters")
    ("1" (my/colorcolumn 100) "100 characters")
    ("2" (my/colorcolumn 120) "120 characters"))))
#+END_SRC

**** Major mode

Thanks to ~major~mode~hydra~ it is possible to easily define
major-mode-specific hydra menus.

See https://github.com/jerrypnz/major-mode-hydra.el

#+BEGIN_SRC emacs-lisp
(use-package major-mode-hydra
  :ensure t
  :config
  (define-key evil-normal-state-map (kbd "S-SPC") 'major-mode-hydra))
#+END_SRC

***** Org

#+BEGIN_SRC emacs-lisp
(major-mode-hydra-define org-mode
  (:color blue :quit-key ("q" "SPC") :title "Org mode")
  ("Actions"
   (("t" my/org-todo-done "Mark TODO item as done")
    ("e" org-edit-special "Edit special")
    ("s" org-edit-src-exit "Save special edit"))))
#+END_SRC

***** Python

#+BEGIN_SRC emacs-lisp
(major-mode-hydra-define python-mode
  (:color blue :quit-key ("q" "SPC") :title "Python mode")
  ("Actions"
   (("d" elpy-doc "Show documentation")
    ("l" hydra-linter/body "Linter"))))
#+END_SRC

***** Markdown

#+BEGIN_SRC emacs-lisp
(major-mode-hydra-define markdown-mode
  (:color blue :quit-key ("q" "SPC") :title "Markdown mode")
  ("Actions"
   (("p" markdown-preview "Preview markdown in external web browser"))))
#+END_SRC

***** Elisp

Lisp interaction mode, aka ~*scratch*~ buffer.

#+BEGIN_SRC emacs-lisp
(major-mode-hydra-define (emacs-lisp-mode lisp-interaction-mode)
  (:color blue :quit-key ("q" "SPC") :title "Lisp interaction mode")
  ("Actions"
   (("e" eval-defun "Evaluate this function")
    ("p" eval-print-last-sexp "Evaluate and print to the buffer"))))
#+END_SRC

***** Circe

Hydra menu for Circe IRC client

#+BEGIN_SRC emacs-lisp
(major-mode-hydra-define (circe-channel-mode circe-server-mode circe-query-mode)
  (:color blue :quit-key ("q" "SPC") :title "Circe")
  ("Away"
   (("c" (circe-command-GAWAY nil) "Clear away status")
    ("1" (circe-command-GAWAY "Training, I will be back within two hours") "Gym")
    ("2" (circe-command-GAWAY "I will be back at work in the evening") "Back in the evening")
    ("a" circe-command-GAWAY "Custom away message"))))
#+END_SRC

* Project management

When working on multiple projects at the same time, it is useful keep some level
of separation between them. This is where ~projectile~ comes handy. It allows you
to easily filter buffers, search files, work with tags and do many more action
within a current project.

As a project is considered every git (or other SCM) repository, or a directory
containing a ~.projectile~ file in it.

See https://github.com/bbatsov/projectile

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :config
  (setq projectile-project-search-path '("~/git/")))
#+END_SRC

TODO Discover projects on startup

The default projectile interface is /meh/ at best, let's use helm.

See https://github.com/bbatsov/helm-projectile

#+BEGIN_SRC emacs-lisp
(use-package helm-projectile
  :ensure t)
#+END_SRC

The only thing that ~projectile~ doesn't allow you to do (at least by default) is
having multiple workspaces/tabs/perspectives or whatever you want to call it and
switching between them. The purpose of such hypothetical workspaces would be to
have one project per workspace that would allow to preserve splits layout when
switching projects. This is essential for me since I work on 5-10 projects
simultaneously.

Such behavior can be achieved using ~eyebrowse~ even though it feels a little
like a workaround. Eyebrowse is not project-oriented by design, it gives you
free hand on what to use workspaces for. For this reason, it lacks certain
project management shortcuts, that I would appreciate.

See https://github.com/wasamasa/eyebrowse

#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :ensure t
  :config
  (eyebrowse-mode t)
  (eyebrowse-setup-opinionated-keys)

  ;; unmap `gc' because it conflicts with `evil-commentary'
  :bind
  (:map evil-normal-state-map
     ("g c" . nil)

   :map evil-motion-state-map
     ("g c" . nil)))
#+END_SRC

Besides hydra, I sometimes use leader key for quickly switching between
eyebrowse workspaces.

#+BEGIN_SRC emacs-lisp
(evil-leader/set-key
  "e" 'eyebrowse-switch-to-window-config)
#+END_SRC

I would like to create a named workspaces so until my eyebrowse patch
gets released (see ~bdc626f~ in eyebrowse repo), let's create the feature here.

#+BEGIN_SRC emacs-lisp
(defun eyebrowse-create-named-window-config ()
  "Creates a window config at a yet unoccupied slot.
User is prompted to provide a tag name, so the window config is
created named."
  (interactive)
  (eyebrowse-create-window-config)
  (eyebrowse-rename-window-config
   (eyebrowse--get 'current-slot)
   (read-string "Tag: ")))
#+END_SRC

When creating a new workspace do not copy the current window layout to it. I
will most likely want only a single window there and split it only when
necessary. This cryptic option means - Create a new workspace with just
~*scratch*~ buffer.

#+BEGIN_SRC
(setq eyebrowse-new-workspace t)
#+END_SRC

My workflow for opening a new project is.

1. Create a new named workspace ~SPC E c~
2. Switch to the desired project ~SPC p~

* Sessions

With Emacs, the idea is to launch it, use it and then never ever close it. Basically
just become one with it and let it consume you. The problem is that sometimes we
just don't have another option than to close it (laptop battery can run out, power
outages, system reboots). All of these sucks by themselves but they can be particularly
painful when hundreds days long Emacs session gets killed and you are forced to start
from scratch.

For this reason, we want to save a current session when closing Emacs and restore it
when launching it. Additionally we want to periodically save the current session to
prevent its lose in more violent situations than ~SIGTERM~.

See https://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Emacs-Sessions.html

#+BEGIN_SRC emacs-lisp
(desktop-save-mode 1)
#+END_SRC

The periodical save is achieved by ~auto-save-*~ settings as a "side effect".

To preserve even splits layout when restoring Emacs from a previous session,
we need to explicitly load saved frameset from ~desktop-saved-frameset~

See https://emacs.stackexchange.com/a/45829

#+BEGIN_SRC emacs-lisp
(setq desktop-restore-forces-onscreen nil)
(add-hook 'desktop-after-read-hook
 (lambda ()
   (frameset-restore
    desktop-saved-frameset
    :reuse-frames (eq desktop-restore-reuses-frames t)
    :cleanup-frames (not (eq desktop-restore-reuses-frames 'keep))
    :force-display desktop-restore-in-current-display
    :force-onscreen desktop-restore-forces-onscreen)))
#+END_SRC

This approach is able to correctly save and restore even ~eyebrowse~ workspaces.

* Upkeep

Since we are running Emacs for months and months without closing, and even if we
do, we restore the whole previous session, it is a good idea to make sure, that
it doesn't waste resources by remembering things that are not necessary.

Midnight mode runs a configured set of actions every /midnight/. By default it
closes every buffer that hasn't been visited in last 3 days.

See https://www.emacswiki.org/emacs/MidnightMode

#+BEGIN_SRC emacs-lisp
(use-package midnight
  :ensure t
  :disabled
  :config
  (midnight-mode))
#+END_SRC

Unforunatelly my hack for not-killing eyebrowse-visible buffers (see
further bellow) stopped working so I need to have ~midnight-mode~
temporarily disabled.

My midnight is definitelly not at midnight because I am definitely up and
working at that time. It is safer to run automaticall tasks early in the
morning.

#+BEGIN_SRC emacs-lisp
(midnight-delay-set 'midnight-delay "4:30am")
#+END_SRC

Never kill circe buffers.

#+BEGIN_SRC emacs-lisp
(defun my/buffer-is-circe-p (buffer-name)
  (with-current-buffer buffer-name
    (derived-mode-p 'lui-mode)))
#+END_SRC

Never kill buffers that are currently /visible/ in any of eyebrowse window
layouts. For that we first need to figure out what buffers are visible
eyebrowse-wide.

#+BEGIN_SRC emacs-lisp
(defun my/eyebrowse-all-buffer-names ()
  (let ((buffer-names (list)))
    (dolist (window-config (eyebrowse--get 'window-configs))
      (eyebrowse--walk-window-config
       window-config
       (lambda (item)
         (when (eq (car item) 'buffer)
           (let ((buffer-name (cadr item)))
             (add-to-list 'buffer-names buffer-name))))))
    buffer-names))
#+END_SRC

And now we can make a predicate to see if some buffer is visible within any
eyebrowse layout.

#+BEGIN_SRC emacs-lisp
(defun my/buffer-is-eyebrowse-visible-p (buffer-name)
  (seq-contains (my/eyebrowse-all-buffer-names) buffer-name))
#+END_SRC

The name ~clean-buffer-list-kill-never-regexps~ is quite confusing because
besides regexps it accepts also funcitons. See documentation for more info but
basically the function takes a buffer name as an argument and returns non-nil
when the buffer should never be killed.

#+BEGIN_SRC emacs-lisp
(setq clean-buffer-list-kill-never-regexps
      (list 'my/buffer-is-circe-p
            'my/buffer-is-eyebrowse-visible-p))
#+END_SRC

* Development


#+BEGIN_SRC emacs-lisp
(use-package fic-mode
  :ensure t
  :config
  (add-hook 'prog-mode-hook 'fic-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  ;; There is a bug visualizing even #def in .Xdefaults
  :ensure t
  :config
  nil)
#+END_SRC

In many programming languages there is a standard line width and code should not
continue over it. Also when writting a text (e.g. documentation) it is better to
hard-wrap the lines somewhere. It makes a review easier, it is much clearer in
diffs, ets. Typically we wrap at 80, 100 or 120 characters.

#+BEGIN_SRC emacs-lisp
(use-package fill-column-indicator
  :ensure t
  :config
  (setq fci-rule-width 1)
  (setq fci-rule-color my/gray))
#+END_SRC

Let's define a function which will color a given column

#+BEGIN_SRC emacs-lisp
(defun my/colorcolumn (column)
  (turn-on-fci-mode)
  (set-fill-column column))
#+END_SRC


#+BEGIN_SRC emacs-lisp
;; (use-package browse-at-remote
;;   ;; https://github.com/rmuslimov/browse-at-remote
;;   :ensure t
;;   :config
;;   nil)

(add-to-list 'load-path "/home/jkadlcik/git/browse-at-remote")
(require 'browse-at-remote)
(setq browse-at-remote-add-line-number-if-no-region-selected nil)
#+END_SRC

** Indentation

Disable ~electric-indent-mode~ because it is trying to be smart and do weird
aggressive indents that are in fact just stupid and only makes me manually remove
and adjust them. Also make sure, that any major mode won't turn it on again.

#+BEGIN_SRC emacs-lisp
(electric-indent-mode -1)
(add-hook 'after-change-major-mode-hook (lambda() (electric-indent-mode -1)))
#+END_SRC

Set tab width and other indentation settings based on the analysis of the
current project.

#+BEGIN_SRC emacs-lisp
(use-package dtrt-indent
  :ensure t
  :config
  (dtrt-indent-global-mode)
  (dtrt-indent-adapt))
#+END_SRC

Map ~ENTER~ key to execute ~newline-and-indent~ in order to eliminate different
indentation from ~ENTER~ and pressing Evil ~o~ command. Hopefully they are the
same, we need some longer observation.

TODO map this for all modes?

#+BEGIN_SRC emacs-lisp
(defun set-newline-and-indent ()
  (local-set-key (kbd "RET") 'newline-and-indent))
(add-hook 'python-mode-hook 'set-newline-and-indent)
#+END_SRC

** Completion

Our completion framework of choice is ~company~.

See https://company-mode.github.io/

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config
  (company-mode))
#+END_SRC

When ~company~ autocomplete menu pops-up, we want to move in it using ~C-n~ and
~C-p~ like in Vim. I am doing this mainly because of Python programming and
Elpy, so if it makes a mess somewhere else, we can just limit this for
~python-mode~.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'company
  (define-key company-active-map (kbd "C-n") 'company-select-next)
  (define-key company-active-map (kbd "C-p") 'company-select-previous))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; (define-key company-search-map (kbd "C-n") 'company-select-next)
  ;; (define-key company-search-map (kbd "C-p") 'company-select-previous)
#+END_SRC

** Whitespace

#+BEGIN_SRC emacs-lisp
;; @TODO try this after restarting emacs
;; https://stackoverflow.com/questions/15946178/change-the-color-of-the-characters-in-whitespace-mode
;; (setq whitespace-display-mappings
;;   ;; all numbers are Unicode codepoint in decimal. ⁖ (insert-char 182 1)
;;   '(
;;     (space-mark 32 [183] [46]) ; 32 SPACE 「 」, 183 MIDDLE DOT 「·」, 46 FULL STOP 「.」
;;     (newline-mark 10 [182 10]) ; 10 LINE FEED
;;     (tab-mark 9 [9655 9] [92 9]) ; 9 TAB, 9655 WHITE RIGHT-POINTING TRIANGLE 「▷」
;;     ))
#+END_SRC

Just remove all trailing whitespace on save. This can be annoying when somebody else already
messed it up and commited to git repo with trailing spaces but overall its the most comfortable
option.

#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'unix-newline)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** Version control

Sometimes it might be useful to visualize git changes within a file
(new and changed lines).

Use ~M-x diff-hl-mode~

#+BEGIN_SRC emacs-lisp
(use-package diff-hl
  :ensure t)
#+END_SRC

** Flycheck

It is handy to have some on-fly syntax and style checker in order to not
produce ugly code.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t)
#+END_SRC

Such tools are typically slow on large files, so to make it (allegedly 10x)
faster, do not highlight words, but rather lines.

#+BEGIN_SRC emacs-lisp
(setq flycheck-highlighting-mode 'lines)
#+END_SRC

Argh, by default flycheck and other tools are so aggressive and distracting
with all the text underlines and other annoying things.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'flycheck-info nil :underline nil)
(set-face-attribute 'flycheck-warning nil :underline nil)
(set-face-attribute 'flycheck-error nil :underline nil)
#+END_SRC

It is not 1970s and we don't use computer terminals with 80x24 characters
resolution anymore. Line length of 120 characters is reasonable enough.

#+BEGIN_SRC emacs-lisp
(setq-default flycheck-flake8-maximum-line-length 120)
#+END_SRC

TODO from below this point, the flycheck configuration is python-specific

Flycheck allows to run only one checker at the time. However, it allows to
chain then and run them sequentially. In this case, after running flake8,
run also a pylint.

#+BEGIN_SRC emacs-lisp
(flycheck-add-next-checker 'python-flake8 'python-pylint)
#+END_SRC

We would like to see symbolic, human readable IDs like ~no-name-in-module~
instead of numeric values like ~E0611~. However, columns width in
~M-x flycheck-list-errors~ are fixed and hardcoded, so just use numbers.

#+BEGIN_SRC emacs-lisp
(setq-default flycheck-pylint-use-symbolic-id nil)
#+END_SRC

Define a function to convert numeric error ID to symbolic.

#+BEGIN_SRC emacs-lisp
(defun pylint-id-to-symbolic (msg-id)
  (let* ((cmd (list "pylint" "--help-msg" msg-id))
         (msg (shell-command-to-string (combine-and-quote-strings cmd)))
         (start (+ (string-match ":" msg) 1))
         (end (string-match ":" msg start))
         (name (substring msg start end)))
    (car (split-string name " "))))
#+END_SRC

We can now disable false positive errors with a symbolic ID

#+BEGIN_SRC emacs-lisp
(defun pylint-disable-warning (msg-id)
  (end-of-line)
  (insert "  " (format "# pylint: disable=%s" msg-id)))
#+END_SRC

Get pylint error ID for the current line

TODO it would be better to have universal ~pylint-error-on-line~ so it easier
to test and then specify line number in ~pylint-disable-current-warning~.

#+BEGIN_SRC emacs-lisp
(defun pylint-current-error ()
  (first (flycheck-overlay-errors-at (point))))
#+END_SRC

Glue everything together in one function to disable pylint warning
for the current line.

See https://www.reddit.com/r/emacs/comments/g31gtn/generate_comment_to_disable_falsepositive_pylint/

#+BEGIN_SRC emacs-lisp
(defun pylint-disable-current-warning ()
  (interactive)
  (pylint-disable-warning
    (pylint-id-to-symbolic
      (flycheck-error-id
        (pylint-current-error)))))
#+END_SRC

** Snippets

It is so boring to type the same things again and again and again,
every day, hundred times a day. I've written the line
~import ipdb; ipdb.set_trace()~ literaly a ten thousand times in my life.
Let's install ~yasnippet~ so we can do just ~ipdb<TAB>~.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :init
  (yas-global-mode 1))
#+END_SRC

By default the snippet manager doesn't come with any snippets. Which is
good idea but we don't really want to write all snippets on our own,
it is a big maintanance overhead. Let's install some snippets collection
and then write/override whatever is needed.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet-snippets
  :ensure t)
#+END_SRC

You can find my custom snippets in ~./snippets/~ directory. When creating
a new snippet, just run ~M-x yas-new-snippet~ and then save it simply as
~:w keyname~. It will store it to an appropriate directory for the current
major mode.

See ~M-x yas-describe-tables~ for all available snippets.

** Languages
*** Python

#+BEGIN_SRC emacs-lisp
(use-package elpy
  ;; sudo dnf install python3-virtualenv
  :ensure t
  :init
  ;; @TODO have some module for snippets
  (setq elpy-modules
        '(elpy-module-sane-defaults
          elpy-module-company
          elpy-module-eldoc
          elpy-module-yasnippet
          elpy-module-django))
  (elpy-enable))
#+END_SRC

Use flycheck instead of flymake

See https://elpy.readthedocs.io/en/latest/customization_tips.html#use-flycheck-instead-of-flymake

#+BEGIN_SRC emacs-lisp
(add-hook 'elpy-mode-hook 'flycheck-mode)
#+END_SRC

*** Lisp

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :config
  (add-hook 'emacs-lisp-mode-hook 'rainbow-delimiters-mode))
#+END_SRC

*** Elm

Elm command line tools (such as ~elm-format~) are not properly packaged in Fedora,
so we need to install them using ~npm~.

#+BEGIN_SRC bash
npm install elm
npm install elm-format
npm install elm-test
#+END_SRC

Extend ~$PATH~ so Emacs can use them.

#+BEGIN_SRC emacs-lisp
(add-to-list 'exec-path (expand-file-name "~/node_modules/.bin"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package elm-mode
  :ensure t
  :config
  (add-hook 'elm-mode-hook 'elm-format-on-save-mode))
#+END_SRC

*** Jinja2

#+BEGIN_SRC emacs-lisp
;; @TODO use jinja2-mode package
#+END_SRC

*** Org

Hint: see Org-Mode Reference Card
https://www.gnu.org/software/emacs/refcards/pdf/orgcard.pdf

Hint: see straightforward, yet comprehensive Org-Mode manual
http://doc.norang.ca/org-mode.html

Every larger document that is trying to look professionally should have
a table of contents. Don't try to maintain it manually, it is the first
step towards insanity. Use ~toc-org~ package instead.

#+BEGIN_SRC emacs-lisp
(use-package toc-org
  :ensure t
  :after org)
#+END_SRC

Now you can put ~:TOC:~ tag to a heading, run ~M-x toc-org-insert-toc~
to generate the initial version based on your document structure and
after this, every time you change the structure and save the document,
TOC will be regenerated.


#+BEGIN_SRC emacs-lisp
(setq org-src-window-setup 'current-window)
(setq org-src-preserve-indentation nil)
(setq org-edit-src-content-indentation 0)
#+END_SRC

See https://stackoverflow.com/a/24173780/3285282

#+BEGIN_SRC emacs-lisp
;; @FIXME doesn't seem to work for GitHub
(setcar (nthcdr 2 org-emphasis-regexp-components) " \t\r\n\"'")
(org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components)
#+END_SRC

I use checklists on a daily basis and often they get quite long. Additionally,
I don't always process them from the beginning to the end but rather randomly,
they are not numbered, so what. Then it can become quite messy when the
completed items are not grayed out. This fixes it.

See https://fuco1.github.io/2017-05-25-Fontify-done-checkbox-items-in-org-mode.html

#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
 'org-mode
 `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:X\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)" 1 'org-headline-done prepend))
 'append)
#+END_SRC

The ~org-headline-done prepend~ face has by default some weird color. It should
be gray ... I mean, we don't say /grayed out/ for no reason.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'org-headline-done nil :foreground my/lgray)
#+END_SRC

Show agendas from these TODO files.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-files '("~/org/gtd/inbox.org"
                         "~/org/gtd/gtd.org"
                         "~/org/gtd/tickler.org"))
#+END_SRC

For the love of god, do not do ~\'reorganize-frame~, nor any other shenanigans.
Why can't Emacs let me do my window management manually instead of trying to
convince applications to behave more friendly one by one.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-window-setup 'current-window)
#+END_SRC

I find the default agenda view too cluttered. Let's install ~org-super-agenda~
which allows us to easily show custom groups of tasks (and display them in
prettified as we want to).

See https://github.com/alphapapa/org-super-agenda

#+BEGIN_SRC emacs-lisp
(use-package org-super-agenda
  :ensure t
  :config
  (org-super-agenda-mode))
#+END_SRC

TODO this is my WIP implementation of super agenda

#+BEGIN_SRC emacs-lisp
(defun my/org-agenda-group-name (icon name)
  (concat
   (propertize (fontawesome icon)
               'face '(:family "FontAwesome"))
   " "
   name))

(defun my/org-agenda ()
  (interactive)
  (let ((org-agenda-span 'day)
	(org-super-agenda-groups
	 `((:name ,(my/org-agenda-group-name "star-o" "Next")
		  :todo "NEXT")

	   (:name ,(my/org-agenda-group-name "flash" "Important")
		  :priority "A")

	   (:name ,(my/org-agenda-group-name "thumb-tack" "Started")
		  :todo "STARTED")

	   (:name ,(my/org-agenda-group-name "clock-o" "Waiting")
		  :todo "WAITING")

	   (:name ,(my/org-agenda-group-name "check-square-o" "TODO")
		  :todo "TODO")

	   (:name ,(my/org-agenda-group-name "exclamation-triangle" "Blocked")
		  :todo "BLOCKED")

	   ;; TODO ideally show finished tasks as a motivation that
	   ;; things are being done
	   (:todo ("DONE" "CANCELLED")))))
    (org-todo-list)))
#+END_SRC

The sequence of possible states for our TODO items. These are just basic ones, I
am trying to keep this sequence as limited as possible. However, in case we need
more complicated state management, we can add another sequences. This can be
useull e.g. for tracking bugs, Trello, JIRA, etc.

See https://orgmode.org/manual/Multiple-sets-in-one-file.html#Multiple-sets-in-one-file

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO(t)"
                  "NEXT(n)"
                  "STARTED(s)"
                  "WAITING(w)"
                  "BLOCKED(b)"
                  "|"
                  "DONE(d)"
                  "CANCELLED(c)")))
#+END_SRC

There are multiple ways to change a state of a TODO item under the cursor, but
all of them are unnecessarily complicated for simply completing the items (which
is the case 90% of times). We can use ~C-c C-t~ to select and switch a new
state, or ~S-RIGHT S-LEFT~ to move in the sequence of states.

See https://orgmode.org/manual/TODO-Basics.html

Let's just have a function to switch TODO item into ~DONE~ state.

#+BEGIN_SRC emacs-lisp
(defun my/org-todo-done ()
  (interactive)
  (org-todo 'done))
#+END_SRC

@TODO Make a helm interface for ~C-c C-t~

When a TODO item is completed, automatically insert a timestamp.

#+BEGIN_SRC emacs-lisp
(setq org-log-done 'time)
#+END_SRC

This is not a piece of configuration but I tend to forget key bindings. It is
possible to schedule a TODO item by pressing ~C-c C-s~. Use shift + arrow keys
to move between dates and time optionally is typed in a prompt.

See https://orgmode.org/manual/The-date_002ftime-prompt.html

Similarly, a deadline can be set by pressing ~C-c C-d~.

See https://orgmode.org/manual/Inserting-deadline_002fschedule.html


TODO org-capture

#+BEGIN_SRC emacs-lisp
(setq org-default-notes-file (concat org-directory "/gtd/inbox.org"))
#+END_SRC

TODO Capture templates for adding TODOs via ~org-agenda~

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
      '(("t" "Todo" entry (file+olp "~/org/gtd/gtd.org" "2020" "Week 45")
         "* TODO %?\n  %i\n  %a")
        ("i" "Inbox" entry (file+headline "~/org/gtd/inbox.org" "Tasks")
         "* TODO %?\n  %i\n  %a")))
#+END_SRC


*** Markdown

See https://stackoverflow.com/a/34672923/3285282

#+BEGIN_SRC emacs-lisp
(defadvice markdown-preview (around markdown-preview-in-chromium activate compile)
   (let ((browse-url-browser-function #'browse-url-chromium))
     ad-do-it))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq browse-url-chromium-program "google-chrome")
#+END_SRC

*** Ascii doc

Just some syntax highlighting for asciidoc manual pages.

#+BEGIN_SRC emacs-lisp
(use-package adoc-mode
  :ensure t)
#+END_SRC

*** RPM spec

Install a package with support for RPM packaging and writing ~.spec~ files.
Besides other things, it provides a template for creating a new spec files.
Just use ~:e ~/rpmbuild/SPECS/foo.spec~ to use it.

#+BEGIN_SRC emacs-lisp
(use-package rpm-spec-mode
  :ensure t)
#+END_SRC

By default the ~rpm-spec-mode~ is not matched with ~.spec~ files, so they are
still automatically opened with ~shell-script-mode~. We need to configure this
to use ~rpm-spec-mode~ instead.

#+BEGIN_SRC emacs-lisp
(setq auto-mode-alist
      (append '(("\\.spec" . rpm-spec-mode))
       auto-mode-alist))
#+END_SRC

The ~rpm-spec-mode~ provides real nice syntax highlighting but unfortunatelly
it uses just straight-horrible colors to do so. Use something more consistent
with the rest of our theme.

#+BEGIN_SRC emacs-lisp
(set-face-attribute 'rpm-spec-tag-face nil :foreground my/blue)
(set-face-attribute 'rpm-spec-obsolete-tag-face nil :foreground my/red)
(set-face-attribute 'rpm-spec-macro-face nil :foreground my/yellow)
(set-face-attribute 'rpm-spec-var-face nil :foreground my/red)
(set-face-attribute 'rpm-spec-doc-face nil :foreground my/purple)
(set-face-attribute 'rpm-spec-dir-face nil :foreground my/green)
(set-face-attribute 'rpm-spec-package-face nil :foreground my/red)
(set-face-attribute 'rpm-spec-ghost-face nil :foreground my/red)
(set-face-attribute 'rpm-spec-section-face nil :foreground my/yellow)
#+END_SRC

TODO it uses tabs! Don't use tabs for god sake

** LSP

#+BEGIN_SRC emacs-lisp
;; When messing with the configuration and going back to elpy, delete
;; these packages with `M-x package-delete'
;;
;; (use-package company
;;   :ensure t
;;   :config
;;   (global-company-mode))

;; (use-package flycheck
;;   :ensure t)

;; (use-package lsp-mode
;;   :ensure t
;;   ;; Support for specific languages:
;;   ;; Python: pip-3 install --user python-language-server[all]

;;   :init
;;   (setq lsp-keymap-prefix "s-l")

;;   ;;@FIXME autocompletion inserts function arguments and it sux
;;   ;;       using elpy until that
;;   ;; :hook
;;   ;; ((python-mode . lsp))

;;   :config
;;   (setq lsp-enable-symbol-highlighting nil)
;;   (setq lsp-signature-auto-activate nil)
;;   (setq lsp-enable-snippet nil)
;;   (setq lsp-enable-completion-at-point nil)

;;   :commands lsp)

;; (use-package lsp-ui
;;   :disabled
;;   :ensure t
;;   :commands lsp-ui-mode)

;; (use-package company-lsp
;;   :ensure t
;;   :config
;;   (setq company-lsp-enable-snippet nil)
;;   :commands company-lsp)

;; (use-package helm-lsp
;;   :ensure t
;;   :commands helm-lsp-workspace-symbol)

;; (setq company-minimum-prefix-length 1
;;       company-idle-delay 0) ;; default is 0.2

;; (add-hook 'prog-mode-hook (lambda () (highlight-indentation-mode -1)))
#+END_SRC

* Writing

First see some cool writing setups from other people:

- https://explog.in/notes/writingsetup.html

When coding, we want to be in a full control of line wrapping and their lengths,
so seeing a vertical ruler and wrapping them manually is ideal. However, when
writing text, it is more of a drag. Let's just hard-wrap all lines automatically
on 80 characters.

#+BEGIN_SRC emacs-lisp
(setq fill-column 80)
(add-hook 'org-mode-hook 'turn-on-auto-fill)
(add-hook 'markdown-mode-hook 'turn-on-auto-fill)
(add-hook 'rst-mode-hook 'turn-on-auto-fill)
(add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; @TODO don't modify modeline
(setq writeroom-fullscreen-effect (quote maximized))
(add-hook 'writeroom-mode-hook
        (lambda ()
          (if writeroom-mode
              (progn
                (blink-cursor-mode 0)  ; turn off blinky cursor
                (fringe-mode 0)  ; hide fringes
                (setq-local inhibit-message t))  ; don't distract
            (progn
              (blink-cursor-mode t)
              (fringe-mode nil)
              (setq-local inhibit-message t)))))


(set-face-attribute 'line-number-current-line nil
  :inverse-video nil
  ;https://github.com/belak/base16-emacs/commit/f701a8e191ae9c0bd6ab93926ce993bb18a9e98c
  ; :foreground "base03"
  ; :background "base01")
)
#+END_SRC

* Applications

If I shoot myself into my leg and accidentally break a buffer by running an
application in it and panicking how to get back, just kill the buffer with
~M-x kill-buffer~.

** Magit
Magit is a well-known killer feature of Emacs and supposedly the
greatest ~git~ interface ever invented.

By default, it doesn't play very well with ~evil-mode~ so let
~evil-magit~ take care of that.

See https://github.com/emacs-evil/evil-magit

#+BEGIN_SRC emacs-lisp
(use-package evil-magit
  :ensure t)
#+END_SRC

The most basic key bindings are

| Key | Action                            | CLI alternative         |
|-----+-----------------------------------+-------------------------|
| s/S | stage a hunk, file or all files   | ~git add -p <file>~     |
| u/U | unstage a hunk, fiel or all files | ~git reset HEAD <file>~ |
| x   | discard                           | ~git checkout <file>~   |
| c   | commit                            | ~git commit~            |
| p/P | push                              | ~git push~              |

For more see https://github.com/emacs-evil/evil-magit#key-bindings

** File manager

There is already an awesome file manager built in Emacs, called ~dired~.

By default it doesn't automatically refresh opened directories, so any
changes from the outside (e.g. file operations done in the command-line)
doesn't apppear and user needs to manually refresh buffers using ~g~.
One of the problems is, that this key binding doesn't work with evil.

#+BEGIN_SRC emacs-lisp
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)
#+END_SRC

In Vim, I was used to open and close NerdTree with ~C-n~. Side-tree
file managers sux but let's keep the shortcut.

#+BEGIN_SRC emacs-lisp
(define-key evil-normal-state-map (kbd "C-n") 'dired-jump)
#+END_SRC

You will probably find these Evil keybindings useful.

| Key binding | Explanation                  |
|-------------+------------------------------|
| RET         | Open a file or directory     |
| +           | Create a directory           |
| d           | Mark a file to be deleted    |
| x           | Delete marked files          |
| -           | Jump to the parent directory |
| C           | Copy a file or directory     |
| R           | Rename a file or directory   |


TODO Prevent ^ from jumping to the parent directory
TODO Bind backspace for accessing the parent directory

** Terminal

I am currently not using a terminal emulator inside of Emacs because all
available options handle terminal applications such as top, htop, docker, etc
very poorly. However, I would like to slowly collect my notes about terminal
emulators here, hoping that one day they will be usable for me.

It is probably related to my current color scheme (~base16-chalk~) but for some
reason, colors doesn't work, ~ls~ fails with ~error in process filter invalid
face unspecified~, and some other strange behavior. Setting
~ansi-term-color-vector~ fixes the issue.

See https://github.com/hlissner/emacs-doom-themes/issues/54#issuecomment-300012999

#+BEGIN_SRC emacs-lisp
(setq ansi-term-color-vector
      [term
       term-color-black
       term-color-red
       term-color-green
       term-color-yellow
       term-color-blue
       term-color-magenta
       term-color-cyan
       term-color-white])
#+END_SRC

First of all, emacs doesn't allow you to create multiple terminals with the same
name, so running ~M-x term~, switching back to previous buffer and then runnnig
~M-x term~ again, it won't spawn a new terminal, but pop-up the previous
one. Naming our terminal buffers properly will allow us to spawn mulltiple
terminal buffers at the same time.

See https://www.youtube.com/watch?v=wRmK7PMnrJg

Also, not naming your terminal windows and terminal tabs (outside the Emacs
world) is disgusting, messy and just a total chaos. So we wan't to properly name
our Emacs terminals anyway.

#+BEGIN_SRC emacs-lisp
(defun named-term (name)
  (interactive "sName: ")
  (command-execute 'term)
  (if (not (string= name ""))
      (rename-buffer name)))
#+END_SRC

@TODO generate a default terminal name with a timestamp or some counter so
      basically everytime ~named-term~ is used, the default spawns a new
      terminal. Only removing the default and leaving empty input would give us
      the one, default ~*terminal*~.
@TODO don't ask me for ~/bin/bash~ all the time

The brightest possiblity for terminal in Emacs is ~vterm~ which
supports even interactive ncurses applications.

See https://github.com/akermu/emacs-libvterm

#+BEGIN_SRC emacs-lisp
(use-package vterm
  :ensure t)
#+END_SRC

@TODO When I go from ~insert~ to ~normal~ mode, move my cursor to the
      midle of the command and press ~i~, the cursor jumps to the end
      of the command. Which is stupid, I know what ~A~ is for, ...
      See https://github.com/akermu/emacs-libvterm/issues/313#issuecomment-658027284

** Web

*** EWW
EWW notes here
Key bindings
https://github.com/emacs-evil/evil-collection/blob/master/modes/eww/evil-collection-eww.el
o - open
go - open in external browser

*** w3m

#+BEGIN_SRC emacs-lisp
(use-package w3m
  :ensure t
  :config
  nil)
#+END_SRC

** Email

Here is a great tutorial for setting up ~mbsync~, ~mu~, and ~mu4e~.
https://www.youtube.com/watch?v=newRHXKm4H4
Unfortunatelly it is only for one email account.

The prerequisite for this setup is having the following packages installed.

#+BEGIN_SRC bash
sudo dnf install isync maildir-utils
#+END_SRC

A ~mu~ index needs to be initialized with an email address.

See https://emacs.stackexchange.com/a/59485

#+BEGIN_SRC bash
mu init --maildir=~/Mail \
        --my-address=frostyx@email.cz \
        --my-address=jakub.kadlcik@gmail.com
mu index --maildir ~/Mail
#+END_SRC

The ~mu4e~ package is not available on MELPA, let's load it from system.

#+BEGIN_SRC emacs-lisp
(use-package mu4e
  :ensure nil
  :load-path "/usr/share/emacs/site-lisp/mu4e"
  :config

  ;; https://etienne.depar.is/emacs.d/mu4e.html
  (setq mu4e-split-view 'horizontal)
  (setq mu4e-headers-visible-columns 67)
  (setq mu4e-html2text-command "w3m -dump -T text/html -cols 72 -o display_link_number=true -o auto_image=false -o display_image=false -o ignore_null_img_alt=true")
  (setq mu4e-view-show-addresses t)
  (setq message-kill-buffer-on-exit t)
  (setq mu4e-update-interval 120) ;; two minutes
  (setq mail-user-agent 'message-user-agent)
  (setq mail-specify-envelope-from t)
  (setq auth-source-debug t)
  (setq auth-source-do-cache nil)


  ;; Sync everything by `mbsync -a`
  (setq mu4e-get-mail-command "mbsync seznam gmail redhat")

  ;; @TODO notifications
  ;; https://github.com/iqbalansari/mu4e-alert

  ;; Havent tested it yet, but it looks like a great feature
  ;; https://www.reddit.com/r/emacs/comments/fu8ln7/in_mu4e_1310_how_do_i_open_an_email_in_browser/fmbbfz2?utm_source=share&utm_medium=web2x
  (add-to-list 'mu4e-view-actions
    '("View in Browser" . mu4e-action-view-in-browser) t))
#+END_SRC


Do not show threads, they are unnecessarily confusinig. They can easily be
toggled on and off by ~z t~, and it is really easy to narrow the search to only
one thread by ~a s~ when reading a message.

Ideally I would prefer something like Gmail threads concept, we might
investigate it in the future.

#+BEGIN_SRC emacs-lisp
(setq mu4e-headers-show-threads nil)
#+END_SRC

The ~mu4e~ system package provides also a library for sending emails.

See https://www.djcbsoftware.nl/code/mu/mu4e/Sending-mail.html

#+BEGIN_SRC emacs-lisp
(use-package smtpmail
  :ensure t
  :load-path "/usr/share/emacs/site-lisp/mu4e")
#+END_SRC

And now some black magic configuration, see

https://www.emacswiki.org/emacs/SendingMail

#+BEGIN_SRC emacs-lisp
(setq message-send-mail-function 'smtpmail-send-it
      starttls-use-gnutls t
      smtpmail-debug-info t)
#+END_SRC

Everyone has at least two email accounts and who sais he doesn't, he is
lying. In Mu4e, accounts are managed through "contexts". For an example contexts
configuration, please see

https://emacs.stackexchange.com/a/50365

First, let's configure my personal email for online stuff.

#+BEGIN_SRC emacs-lisp
(setq my/mu4e-seznam-context
      (make-mu4e-context
       :name "seznam"
       :enter-func (lambda () (mu4e-message "Entering seznam context"))
       :leave-func (lambda () (mu4e-message "Leaving seznam context"))
       :match-func (lambda (msg)
		     (when msg
		       (mu4e-message-contact-field-matches
			msg '(:from :to :cc :bcc) "frostyx@email.cz")))
       :vars '((user-mail-address . "frostyx@email.cz")
               (user-full-name . "Jakub Kadlčík")
               (smtpmail-smtp-user . "frostyx@email.cz")
               (smtpmail-default-smtp-server . "smtp.seznam.cz")
               (smtpmail-smtp-server . "smtp.seznam.cz")
               (smtpmail-smtp-service . 587)
               (mu4e-sent-messages-behavior . sent))))
#+END_SRC

Now, my personal Gmail account for IRL stuff.

#+BEGIN_SRC emacs-lisp
(setq my/mu4e-gmail-context
      (make-mu4e-context
       :name "gmail"
       :enter-func (lambda () (mu4e-message "Entering gmail context"))
       :leave-func (lambda () (mu4e-message "Leaving gmail context"))
       :match-func (lambda (msg)
		     (when msg
		       (mu4e-message-contact-field-matches
			msg '(:from :to :cc :bcc) "jakub.kadlcik@gmail.com")))
       :vars '((user-mail-address . "jakub.kadlcik@gmail.com")
	       (user-full-name . "Jakub Kadlčík")
	       (smtpmail-smtp-user . "jakub.kadlcik")
	       (smtpmail-default-smtp-server . "smtp.gmail.com")
	       (smtpmail-smtp-server . "smtp.gmail.com")
	       (smtpmail-smtp-service . 587)
	       (mu4e-sent-messages-behavior . delete))))
#+END_SRC

And lastly, my work email account.

#+BEGIN_SRC emacs-lisp
(setq my/mu4e-redhat-context
      (make-mu4e-context
       :name "redhat"
       :enter-func (lambda () (mu4e-message "Entering redhat context"))
       :leave-func (lambda () (mu4e-message "Leaving redhat context"))
       :match-func (lambda (msg)
		     (when msg
		       (mu4e-message-contact-field-matches
			msg '(:from :to :cc :bcc) "jkadlcik@redhat.com")))
       :vars '((user-mail-address . "jkadlcik@redhat.com")
	       (user-full-name . "Jakub Kadlčík")
	       (smtpmail-smtp-user . "jkadlcik@redhat.com")
	       (smtpmail-default-smtp-server . "smtp.gmail.com")
	       (smtpmail-smtp-server . "smtp.gmail.com")
	       (smtpmail-smtp-service . 587)
	       (mu4e-sent-messages-behavior . delete))))
#+END_SRC

So far, we only created those context configurations. They need to be passed to mu4e.

#+BEGIN_SRC emacs-lisp
(setq mu4e-contexts (list my/mu4e-seznam-context
			  my/mu4e-gmail-context
			  my/mu4e-redhat-context))
#+END_SRC

Authentication for receiving emails is managed elsewhere but for sending emails,
we need to configure it here. Let's store passwords in the ~pass~ utility (obviously).

#+BEGIN_SRC emacs-lisp
(setq auth-sources '(password-store))
#+END_SRC

Try to send an email and see if it fails. If yes, check ~*Messages*~ buffer for
a bunch of lines like this. Hint, don't launch ~mu4e~ for testing this, use ~C-x
m~ shortcut.

#+BEGIN_SRC
auth-source-pass: found no entries matching "frostyx@email.cz@smtp.seznam.cz"
auth-source-pass: found no entries matching "smtp.seznam.cz:587/frostyx@email.cz"
auth-source-pass: found no entries matching "smtp.seznam.cz/frostyx@email.cz"
#+END_SRC

Pick whichever is the most suitable format to you and add a password for it into
your ~pass~ database. Personally, I did

#+BEGIN_SRC bash
pass insert email/frostyx@email.cz@seznam.cz
pass insert email/jakub.kadlcik@gmail.com
pass insert email/jkadlcik@redhat.com@gmail.com
#+END_SRC


Mu4e offers a possiblity to use symbols instead of letters, however it doesn't
really work. The output of messages list is weirdly aligned.

See https://github.com/djcb/mu/issues/1062

For the time being, let's go with non-fancy characters. But a possible solution
would be to add a space after some special characters, see the linked issue.

#+BEGIN_SRC emacs-lisp
(setq mu4e-use-fancy-chars t)
(setq mu4e-headers-unread-mark '("u" . "u")
      mu4e-headers-draft-mark '("D" . "D")
      mu4e-headers-seen-mark '("S" . "S")
      mu4e-headers-unseen-mark '("u" . "u")
      mu4e-headers-flagged-mark '("F" . "F")
      mu4e-headers-new-mark '("N" . "N")
      mu4e-headers-replied-mark '("R" . "R")
      mu4e-headers-passed-mark '("P" . "P")
      mu4e-headers-encrypted-mark '("x" . "x")
      mu4e-headers-signed-mark '("s" . "s")
      mu4e-headers-trashed-mark '("T" . "T")
      mu4e-headers-attach-mark '("a" . "a"))
#+END_SRC

Let's customize the columns that should be showed in the messages list. Each
column should be set as a pair of a field and its width (it can be ~nil~, in
that case the column width is going to be unlimited. Better to only use that for
the last column)

#+BEGIN_SRC emacs-lisp
(setq mu4e-headers-fields
      '((:from . 20)
        (:thread-subject . nil)))
#+END_SRC

Ideally we would like to have a multiple headers views, one slim, designed for
80 column window, other full-sized.

#+BEGIN_SRC emacs-lisp
(setq my/mu4e-headers-fields-full
      '((:human-date . 20)
        (:flags . 10)
        (:from . 30)
        (:thread-subject . nil)))
#+END_SRC

We set a human-readable date/time format in the messages list view, so we should
rather a one, that is really readable for us (i.e. not the American one).

#+BEGIN_SRC emacs-lisp
(setq mu4e-headers-date-format "%d. %m. %Y")
(setq mu4e-headers-time-format "%H:%M")
#+END_SRC


We don't always want to dig through the entire mailbox but rather see a filtered
mail, e.g. last weeks mail for a specific email address. Mu4e bookmarks are the
thing.

See https://www.djcbsoftware.nl/code/mu/mu4e/Bookmarks.html

#+BEGIN_SRC emacs-lisp
(custom-reevaluate-setting 'mu4e-bookmarks)

(add-to-list 'mu4e-bookmarks
  '(:name "Red Hat shortcut"
    :query "date:1w.. and maildir:/redhat/INBOX/"
    :key ?r))

(add-to-list 'mu4e-bookmarks
  '(:name "Gmail shortcut"
    :query "date:1w.. and maildir:/gmail/*/"
    :key ?g))

(add-to-list 'mu4e-bookmarks
  '(:name "Seznam shortcut"
    :query "date:1w.. and maildir:/seznam/I/BOX/"
    :key ?s))
#+END_SRC

** RSS

Probably the best available RSS client for Emacs is elfeed. It allows
asynchronious sync, automatical refresh by using internal timers, and more.
It provides a user-interface decoupled from the backend logic so we have an
opportunity to implement our own views.

#+BEGIN_SRC emacs-lisp
(use-package elfeed
  :ensure t
  :commands (elfeed)
  :config
  (setq-default elfeed-search-filter ""))
#+END_SRC

Managing our RSS feeds in org file is much more cool than having them in
a list of lists.

#+BEGIN_SRC emacs-lisp
(use-package elfeed-org
  :ensure t
  :config
  (elfeed-org))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq rmh-elfeed-org-files (list "~/.emacs.d/elfeed.org"))
#+END_SRC

Automatically fetch updates from RSS feeds. Let's do it every day, but I am
afraid, that it will lag the whole Emacs, so we will probably need to adjust it
and run less frequently.

See:
- https://github.com/skeeto/elfeed/issues/304
- https://www.reddit.com/r/emacs/comments/bvbp92/is_there_a_simple_way_to_get_elfeed_to_update/

#+BEGIN_SRC emacs-lisp
(setq my/elfeed-update-timer
  (run-at-time nil (* 1 60 60 24) #'elfeed-update))
#+END_SRC

Use ~M-x helm-timers~ to see (and cancel) executed timers.

Very likely we will need to execute operation accross every displayed article

See https://emacs.stackexchange.com/a/2441

#+BEGIN_SRC emacs-lisp
(defun elfeed-apply-for-all (f)
  (interactive)
  (mark-whole-buffer)
  (f))
#+END_SRC

Such as marking everything as read

#+BEGIN_SRC emacs-lisp
(defun elfeed-mark-all-as-read ()
  (elfeed-apply-for-all elfeed-search-untag-all-unread))
#+END_SRC

You will probably find these keybindings useful.

| Key binding | Explanation                   |
|-------------+-------------------------------|
| RET         | Open article in elfeed        |
| o           | Open article in a web browser |
| r           | Fetch new articles            |
| u           | Mark article as read          |
| U           | Mark article as unread        |
| +           | Add tag                       |
| -           | Remove tag                    |
| S           | Stop all fetching processes   |

Define custom key bindings for the list of articles

#+BEGIN_SRC emacs-lisp
(with-eval-after-load "elfeed-search"
  (evil-define-key*
    'normal elfeed-search-mode-map
    "RET" #'elfeed-search-show-entry
    "o" #'elfeed-search-browse-url
    "r" #'elfeed-search-fetch
    "S" #'elfeed-unjam))
#+END_SRC

Define custom key bindings for when reading an article

#+BEGIN_SRC emacs-lisp
(with-eval-after-load "elfeed-show"
  (evil-define-key*
    'motion elfeed-show-mode-map
    "gb" #'elfeed-show-visit
    "gj" #'elfeed-show-next
    "gk" #'elfeed-show-prev))
#+END_SRC

** IRC

There are several Emacs IRC clients available (such as ERC, rcirc and others)
but Circe is the one trying to be modern and be pretty out of the box.

See https://github.com/jorgenschaefer/circe

#+BEGIN_SRC emacs-lisp
(use-package circe
  :ensure t)
#+END_SRC

Do not forget to kill circe and run it again after modifying
~circe-network-options~ variable.

#+BEGIN_SRC emacs-lisp
(setq circe-network-options
      `(("Freenode"
         :tls t
         :nick "FrostyX"

         :sasl-username "FrostyX"
         :sasl-password ,(password-store-get "irc/freenode-password")

         :nickserv-nick "FrostyX"
         :nickserv-password ,(password-store-get "irc/freenode-password")

         :channels ("#fedora-admin"
                    "#fedora-buildsys"
                    "#tito"
                    "#emacs-circe"))
        ("OFTC"
         :tls t
         :nick "FrostyX"
         :channels ("#qtile"))
        ("RedHat"
         :host ,(password-store-get "irc/redhat-host")
         :port 6667
         :tls nil
         :nick "jkadlcik"
         :channels ("#brno" "#copr"))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my/circe ()
  (interactive)
  (circe "Freenode")
  (circe "OFTC")
  (circe "RedHat"))
#+END_SRC

TODO If you want to quit IRC ... insert funny joke from wiki use
     ~M-x kill-buffer~ and select the freenode server buffer.

By default, circe doesn't support notifications. Luckily it is a matter of
installing one additional package.

See https://github.com/eqyiel/circe-notifications

#+BEGIN_SRC emacs-lisp
(use-package circe-notifications
  :ensure t
  :config
  (enable-circe-notifications))
#+END_SRC

By default, typical ~libnotify~ notifications are sent. You can emulate them by
~/usr/bin/notify-send~ command. This is not what I like.
My notification style of choice is setting window urgency. Window managers
typically know that there is an urgent window on some workspace/group and
highlight them in the panel.

See https://github.com/jwiegley/alert#builtin-alert-styles

#+BEGIN_SRC emacs-lisp
(setq circe-notifications-alert-style 'x11)
#+END_SRC

It doesn't matter when I was notified from some user the last time. Notify me
again. It's not spam.

#+BEGIN_SRC emacs-lisp
(setq circe-notifications-wait-for 0)
#+END_SRC

Chat history is important. Enable logging.

#+BEGIN_SRC emacs-lisp
(setq lui-logging-directory "~/.emacs.d/circe")
(load "lui-logging" nil t)
(enable-lui-logging-globally)
#+END_SRC

Make sure that we see lags and automatically reconnects if we got disconnected.

#+BEGIN_SRC emacs-lisp
(circe-lagmon-mode)
#+END_SRC

By default, circe only tries to reconnect back to server a given number of times
and then gives up. We want to keep trying indefinitely even though it is not
recommended.

#+BEGIN_SRC emacs-lisp
(setq circe-server-max-reconnect-attempts nil)
#+END_SRC

Let us know that it is a new day so we can go to bed already.

FIXME I needed to disable it oterwise it messes with tracking

#+BEGIN_SRC emacs-lisp
;; (enable-circe-new-day-notifier)
#+END_SRC

Living without TAB completion for nicknames is out of the question.

#+BEGIN_SRC emacs-lisp
(setq circe-use-cycle-completion t)
#+END_SRC

But we definitelly don't want to use helm for it.

See https://github.com/jorgenschaefer/circe/wiki/Configuration#tab-completion

#+BEGIN_SRC emacs-lisp
(setq my/circe-major-modes
      '(circe-channel-mode
        circe-query-mode
        circe-server-mode))
(setq helm-mode-no-completion-in-region-in-modes my/circe-major-modes)
#+END_SRC

See the newest buffer activity fist. But also, prioritize notifications over
just normal messages in a channel.

#+BEGIN_SRC emacs-lisp
(setq tracking-most-recent-first t)
(setq tracking-sort-faces-first t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq tracking-shorten-buffer-names-p nil)
#+END_SRC

I would prefer to set maximum with of the segment (probably in percentages in
ratio to the current width of the bar/window) but that doesn't seem to be
supported and I don't want to implement the feature right now, so let's just set
the maximum number of displayed buffers in the tracking segment. If we don't do
so, the output might get too lengthy and not be displayed at all. This still
might happen, when the channel names are too long but it's better than nothing.

#+BEGIN_SRC emacs-lisp
(setq tracking-max-mode-line-entries 3)
#+END_SRC

Define a custom spaceline segment for showing a list of channels with activity.
See https://github.com/TheBB/spaceline/issues/39#issuecomment-218469366

TODO we want better colors here, highlight needs to be red

#+BEGIN_SRC emacs-lisp
(spaceline-define-segment circe-track
  (when (and tracking-buffers
             (member major-mode my/circe-major-modes))
    (tracking-status))
  :priority 99)
#+END_SRC

Define a custom spaceline segment for showing the current IRC network lag.

TODO When lag <= 0.1, show "online" in green color

#+BEGIN_SRC emacs-lisp
(spaceline-define-segment circe-lagmon
  (when (and circe-lagmon-mode
             (member major-mode my/circe-major-modes))
    (circe-lagmon-format-mode-line-entry))
  :face other-face
  :priority 99)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(spaceline-toggle-circe-track-on)
(spaceline-toggle-circe-lagmon-on)
(spaceline-spacemacs-theme 'circe-lagmon 'circe-track)
(spaceline-compile)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq circe-format-say "<{nick}>  {body}")
#+END_SRC

See https://github.com/jorgenschaefer/circe/wiki/Configuration#inline-nick-reply

#+BEGIN_SRC emacs-lisp
(setq circe-format-self-say "<{nick}>  {body}")
#+END_SRC

See https://github.com/jorgenschaefer/circe/wiki/Configuration#channel-name-in-the-prompt

#+BEGIN_SRC emacs-lisp
(add-hook 'circe-chat-mode-hook 'my-circe-prompt)
(defun my-circe-prompt ()
  (lui-set-prompt
   (concat "[" (propertize (buffer-name) 'face 'circe-prompt-face) "]  ")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(enable-circe-color-nicks)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my/circe-autoscroll ()
  (setq scroll-down-aggressively 0.5))
(add-hook 'lui-mode-hook 'my/circe-autoscroll)
#+END_SRC

Hard wrap at 70 characters. This is a limit specifically for the message
body. With timestamp prefix, the columns are basically 80 characters long.

#+BEGIN_SRC emacs-lisp
(setq lui-fill-column 70)
#+END_SRC

Ideally we would like to indent the message to the
exact column that it started but it is not that easy. So until then, indent new
lines of a message with a typical 4 spaces.

#+BEGIN_SRC emacs-lisp
(setq lui-fill-type "    ")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq lui-time-stamp-position 'left)
(setq lui-time-stamp-format "[%H:%M]  ")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq lui-time-stamp-only-when-changed-p nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq circe-reduce-lurker-spam t)
#+END_SRC

See https://emacs.stackexchange.com/a/37515

#+BEGIN_SRC emacs-lisp
(setq my/circe-buffers-source
  (helm-make-source "Circe Buffers" 'helm-source-buffers
    :buffer-list
    (lambda ()
      (mapcar #'buffer-name
              (cl-remove-if-not
               (lambda (buf)
                 (with-current-buffer buf
                   (derived-mode-p 'lui-mode)))
               (buffer-list))))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun my/circe-switch-to-buffer ()
  (interactive)
  (let ((helm-source-buffers-list my/circe-buffers-source))
    (helm-buffers-list)))
#+END_SRC

Sometimes it is usefull to just navigate with arrow keys in prompt to repeat
previous messages. By default, this feature is bound to ~M-p~ and ~M-n~ but it
coildes with my Window Manager key bindings, so let's just use arrow keys. I use
~hjkl~ for movement anyway.

#+BEGIN_SRC emacs-lisp
(define-key circe-channel-mode-map (kbd "<up>") 'lui-previous-input)
(define-key circe-channel-mode-map (kbd "<down>") 'lui-next-input)
#+END_SRC


TODO my messages format
TODO highlight color
TODO time stamp gray color and remove brackts
TODO Day changed message like in weechat
TODO logging file format like weechat has, see ~lui-logging-file-format~
TODO change message format (date should go before nick)

TODO ignore non-user messages in tracklist
TODO read message from tracklist when switching window (not only when switching buffer)
TODO maximum length for tracklist

** Spotify

For quick searches and control, ~spotify-helm-plus~ is the best available
client. It has many shortcomings though. It seems like it requires the official
Spotify client running on the system, it doesn't allow searching albums, and it
doesn't customizing the output with e.g. colors or string format. Other than
that, it works quite alright.

See https://github.com/wandersoncferreira/helm-spotify-plus

#+BEGIN_SRC emacs-lisp
(use-package helm-spotify-plus
  :ensure t)
#+END_SRC

The project is an improvment of the former ~helm-spotify~, so for more
information see the original project.

See https://github.com/krisajenkins/helm-spotify

On the contrary to the documentation, use ~C-z~ to see possible actions, such as
playing the whole album.

The ~helm-spotify-plus~ is only good for a fast control, it doesn't provide any
browsing capabilities (I don't know if as a bug or feature, but it could be
awesome). Hence, let's use some another tool for that.

#+BEGIN_SRC emacs-lisp
;; This spotify library is not in MELPA yet,
;; see https://github.com/danielfm/spotify.el/issues/44
;;
;; Also, for playing, web player (or other device) must be opened
;; See https://github.com/danielfm/spotify.el/#selecting-a-device-for-playback
(add-to-list 'load-path "/home/jkadlcik/git/spotify.el")
(require 'spotify)
(setq spotify-oauth2-client-id (password-store-get "spotify/client-id"))
(setq spotify-oauth2-client-secret (password-store-get "spotify/client-secret"))
(setq spotify-transport 'connect)
(define-key spotify-mode-map (kbd "C-c .") 'spotify-command-map)

;; https://github.com/danielfm/spotify.el#remote-minor-mode
(evil-define-key 'normal spotify-mode-map (kbd "q") 'spotify-quit)  ;; @FIXME doesn't work, probably create an issue
(evil-define-key 'normal spotify-mode-map (kbd "go") 'spotify-track-select)
(evil-define-key 'normal spotify-mode-map (kbd "gp") 'spotify-toggle-play)
(evil-define-key 'normal spotify-mode-map (kbd "g<") 'spotify-previous-track)
(evil-define-key 'normal spotify-mode-map (kbd "g>") 'spotify-next-track)
(evil-define-key 'normal spotify-mode-map (kbd "gd") 'spotify-select-device)
#+END_SRC

Let's add a hydra menu, so we don't have to remember the commands or shotcuts.

#+BEGIN_SRC emacs-lisp
(pretty-hydra-define hydra-spotify
  (:color blue :quit-key ("q" "SPC") :title "Spotify")
  ("Search"
   (("s" helm-spotify-plus "Search in helm"))

   ;; These are very likely obsolete by Window manager key bindings but it
   ;; doesn't hurt to have a spare in case we are in a foreign environment
   ;; just with Emacs.
   "Control"
   (("p" helm-spotify-plus-toggle-play-pause "Play / Pause")
    ("<" helm-spotify-plus-previous "Previous")
    (">" helm-spotify-plus-next "Next"))

   "Browse"
   (("P" spotify-my-playlists "My playlists")
    ("r" sporify-recently-played "Recently played"))))
#+END_SRC

*** Vuivet

TODO see Vuivet, it should have some spotify features

See:
- http://mihaiolteanu.me/vuiet/
- https://github.com/mihaiolteanu/vuiet

** NetworkManager

#+BEGIN_SRC emacs-lisp
(use-package enwc
  :ensure t
  :config
  (setq enwc-default-backend 'nm)
  (setq enwc-wireless-device 'wlp2s0)
  ;; (define-key enwc-mode-map (kbd "C") 'enwc-connect-to-network-essid)
  nil)

;; (evil-add-hjkl-bindings enwc-mode-map 'emacs
;;   (kbd "/")       'evil-search-forward
;;   (kbd "n")       'evil-search-next
;;   (kbd "N")       'evil-search-previous
;;   (kbd "C-d")     'evil-scroll-down
;;   (kbd "C-u")     'evil-scroll-up
;;   (kbd "C-w C-w") 'other-window)

;; (use-package powerline
;;   :ensure t
;;   :config
;;   (powerline-default-theme))
#+END_SRC

** Bluetooth
See https://github.com/emacsmirror/bluetooth

#+BEGIN_SRC bash
dnf install bluez-hid2hci
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package bluetooth
  :ensure t)
#+END_SRC

See https://emacs.stackexchange.com/questions/31244/how-can-i-disable-evil-in-help-mode?rq=1

#+BEGIN_SRC emacs-lisp
(evil-set-initial-state 'bluetooth-mode 'emacs)
(evil-add-hjkl-bindings bluetooth-mode-map 'emacs)
#+END_SRC

** Pulseaudio

TODO write my own plugin for switching output devices

Here is a bash workflow

See https://askubuntu.com/a/72076

#+BEGIN_SRC bash
# See available output devices (e.g. 1. speakers, 2. bluetooth headphones)
pacmd list-sinks

# Change default output device for new applications
pacmd set-default-sink 2

# See all currently running applications having output
# e.g. chromium with id 1712
pacmd list-sink-inputs

# Then go through all those applications and switch their outpud device
pacmd move-sink-input 1712 1
#+END_SRC

* Beyond Emacs
** Edit with Emacs (in Google Chrome)
/Edit with Emacs/ is a Google Chrome extension allowing to pop-up a new Emacs
frame to edit a textarea.

See https://chrome.google.com/extensions/detail/ljobjlafonikaiipfkggjbhkghgicgoh

The usage is easy, just right-click a ~<textarea>~ and click ~Edit with
Emacs~. This feature doesn't work for "rich editors", e.g. Gmail, Grammarly,
etherpads, etc.

Some configuration is required on the Emacs part.

See https://github.com/stsquad/emacs_chrome

#+BEGIN_SRC emacs-lisp
(use-package edit-server
  :ensure t
  :config
  (edit-server-start))
#+END_SRC

I probably don't need (most of) this configuration because of using a tiling
window manager. The size and position of this new frame will be determined
solely by my WM workspace layout. I am leaving it here in case I was forced to
work in a shitty DE.

#+BEGIN_SRC emacs-lisp
(setq edit-server-new-frame-alist
      '((name . "Edit with Emacs FRAME")
        (top . 200)
        (left . 200)
        (width . 80)
        (height . 25)
        (minibuffer . t)
        (menu-bar-lines . t)
        (window-system . x)))
#+END_SRC

* Resources

** Other people configs

- https://github.com/angrybacon/dotemacs/blob/master/dotemacs.org
- https://wolfecub.github.io/dotfiles/
- https://jamiecollinson.com/blog/my-emacs-config/
- https://emacs.nasy.moe/
- https://se30.xyz/conf.html
- https://depp.brause.cc/dotemacs/#org22ed5c7 (wasamasa)

** Videos

- DistroTube - https://www.youtube.com/channel/UCVls1GmFKf6WlTraIb_IaJg
- Protesilaos Stavrou - https://www.youtube.com/channel/UC0uTPqBCFIpZxlz_Lv1tk_g
